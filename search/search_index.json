{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Motivation Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. Yet, beneath this simplicity lies a complex and versatile framework. The equations governing projectile motion involve both linear and quadratic relationships, making them accessible yet deeply insightful. What makes this topic particularly compelling is the number of free parameters involved in these equations, such as initial velocity, gravitational acceleration, and launch height. These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket. Task 1. Theoretical Foundation Begin by deriving the governing equations of motion from fundamental principles. This involves solving a basic differential equation to establish the general form of the motion. Highlight how variations in initial conditions lead to a family of solutions. 2. Analysis of the Range Investigate how the horizontal range depends on the angle of projection. Discuss how changes in other parameters, such as initial velocity and gravitational acceleration, influence the relationship. 3. Practical Applications Reflect on how this model can be adapted to describe various real-world situations, such as projectiles launched on uneven terrain or in the presence of air resistance. 4. Implementation Develop a computational tool or algorithm to simulate projectile motion. Visualize the range as a function of the angle of projection for different sets of initial conditions. Theoretical Solutions The equations of motion governing projectile motion are given by: \\[ x(t) = v_0 \\cos(\\theta) t \\] \\[ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] The total time of flight is: \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\] The range of the projectile is: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] The maximum height reached is: \\[ H = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\] Python Code for Simulation import numpy as np def projectile_range(v0, theta, g=9.81): \"\"\"Compute the range of a projectile given initial velocity and launch angle.\"\"\" theta_rad = np.radians(theta) return (v0**2 * np.sin(2 * theta_rad)) / g # Parameters v0 = 20 # Initial velocity in m/s theta_values = np.linspace(0, 90, num=100) # Angle range from 0 to 90 degrees ranges = [projectile_range(v0, theta) for theta in theta_values] Deliverables A Markdown document with Python script or notebook implementing the simulations. A detailed description of the family of solutions derived from the governing equations. Graphical representations of the range versus angle of projection, highlighting how different parameters influence the curve. A discussion on the limitations of the idealized model and suggestions for incorporating more realistic factors, such as drag or wind. Hints and Resources Start from the fundamental laws of motion and gradually build the general solution. Use numerical methods or simulation tools to explore scenarios that go beyond simple analytical solutions. Consider how this model connects to real-world systems, such as sports, engineering, and astrophysics. This task encourages a deep understanding of projectile motion while showcasing its versatility and applicability across various domains.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. Yet, beneath this simplicity lies a complex and versatile framework. The equations governing projectile motion involve both linear and quadratic relationships, making them accessible yet deeply insightful. What makes this topic particularly compelling is the number of free parameters involved in these equations, such as initial velocity, gravitational acceleration, and launch height. These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#task","text":"","title":"Task"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Begin by deriving the governing equations of motion from fundamental principles. This involves solving a basic differential equation to establish the general form of the motion. Highlight how variations in initial conditions lead to a family of solutions.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"Investigate how the horizontal range depends on the angle of projection. Discuss how changes in other parameters, such as initial velocity and gravitational acceleration, influence the relationship.","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Reflect on how this model can be adapted to describe various real-world situations, such as projectiles launched on uneven terrain or in the presence of air resistance.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"Develop a computational tool or algorithm to simulate projectile motion. Visualize the range as a function of the angle of projection for different sets of initial conditions.","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#theoretical-solutions","text":"The equations of motion governing projectile motion are given by: \\[ x(t) = v_0 \\cos(\\theta) t \\] \\[ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] The total time of flight is: \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\] The range of the projectile is: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] The maximum height reached is: \\[ H = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\]","title":"Theoretical Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code-for-simulation","text":"import numpy as np def projectile_range(v0, theta, g=9.81): \"\"\"Compute the range of a projectile given initial velocity and launch angle.\"\"\" theta_rad = np.radians(theta) return (v0**2 * np.sin(2 * theta_rad)) / g # Parameters v0 = 20 # Initial velocity in m/s theta_values = np.linspace(0, 90, num=100) # Angle range from 0 to 90 degrees ranges = [projectile_range(v0, theta) for theta in theta_values]","title":"Python Code for Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#deliverables","text":"A Markdown document with Python script or notebook implementing the simulations. A detailed description of the family of solutions derived from the governing equations. Graphical representations of the range versus angle of projection, highlighting how different parameters influence the curve. A discussion on the limitations of the idealized model and suggestions for incorporating more realistic factors, such as drag or wind.","title":"Deliverables"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#hints-and-resources","text":"Start from the fundamental laws of motion and gradually build the general solution. Use numerical methods or simulation tools to explore scenarios that go beyond simple analytical solutions. Consider how this model connects to real-world systems, such as sports, engineering, and astrophysics. This task encourages a deep understanding of projectile motion while showcasing its versatility and applicability across various domains.","title":"Hints and Resources"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is an intriguing physical system exhibiting complex behaviors due to the interplay of damping, restoring forces, and external periodic forcing. By introducing both damping and external forcing, the system transitions from simple harmonic motion to a spectrum of dynamics, including resonance, chaos, and quasiperiodic motion. These phenomena help in understanding real-world applications such as driven oscillators, climate systems, and mechanical structures under periodic stress. Forcing introduces new parameters, such as amplitude and frequency of the external force, significantly influencing the pendulum\u2019s behavior. By systematically varying these parameters, diverse solutions emerge, including synchronized oscillations, chaotic motion, and resonance phenomena. These behaviors not only highlight fundamental physics principles but also provide insights into engineering applications like energy harvesting, vibration isolation, and mechanical resonance. Task 1. Theoretical Foundation Consider the differential equation governing the forced damped pendulum: $$ \\frac{d^2 \\theta}{dt^2} + b \\frac{d \\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) $$ Derive approximate solutions for small-angle oscillations. Explore resonance conditions and their impact on the system\u2019s energy. 2. Analysis of Dynamics Investigate how the damping coefficient, driving amplitude, and frequency affect the pendulum\u2019s motion. Examine the transition between regular and chaotic motion and its physical interpretations. 3. Practical Applications Discuss real-world applications of the forced damped pendulum, such as energy harvesting devices, suspension bridges, and oscillating circuits. 4. Implementation Develop a computational model to simulate the motion of the forced damped pendulum. Visualize behavior under various damping, driving forces, and initial conditions. Plot phase diagrams and Poincar\u00e9 sections to illustrate transitions to chaos. Implementation in Python ( ) Below is a Python implementation using numerical methods to solve the forced damped pendulum equation and visualize its behavior. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # Gravity (m/s^2) L = 1.0 # Length of pendulum (m) b = 0.5 # Damping coefficient A = 1.2 # Driving force amplitude omega = 2.0 # Driving force frequency # Differential equation def forced_damped_pendulum(t, y): theta, omega_t = y dtheta_dt = omega_t domega_dt = - (g / L) * np.sin(theta) - b * omega_t + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Time span and initial conditions t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) y0 = [np.pi / 4, 0] # Initial angle and angular velocity # Solve the differential equation sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Plot results plt.figure(figsize=(10, 5)) plt.plot(sol.t, sol.y[0], label='Theta (rad)') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show() This code numerically solves the forced damped pendulum equation and visualizes the pendulum's motion over time. Deliverables A Markdown document with a Python script implementing the simulations. A detailed explanation of the general solutions for the forced damped pendulum. Graphical representations of the motion for different damping coefficients, driving amplitudes, and frequencies, including resonance and chaotic behavior. A discussion on model limitations and potential extensions, such as nonlinear damping or non-periodic driving forces. Phase portraits, Poincar\u00e9 sections, and bifurcation diagrams to analyze transitions to complex dynamics. Hints and Resources For small angles, approximate \\( \\sin \\theta \\approx \\theta \\) to simplify the equation. Use numerical techniques (e.g., Runge-Kutta methods) to explore dynamics beyond the small-angle approximation. Relate the forced damped pendulum to analogous systems in other fields, such as electrical circuits (driven RLC circuits) or biomechanics (human gait). Utilize software tools like Python for simulations and visualizations. This task bridges theoretical analysis with computational exploration, fostering a deeper understanding of forced and damped oscillatory phenomena and their implications in physics and engineering.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is an intriguing physical system exhibiting complex behaviors due to the interplay of damping, restoring forces, and external periodic forcing. By introducing both damping and external forcing, the system transitions from simple harmonic motion to a spectrum of dynamics, including resonance, chaos, and quasiperiodic motion. These phenomena help in understanding real-world applications such as driven oscillators, climate systems, and mechanical structures under periodic stress. Forcing introduces new parameters, such as amplitude and frequency of the external force, significantly influencing the pendulum\u2019s behavior. By systematically varying these parameters, diverse solutions emerge, including synchronized oscillations, chaotic motion, and resonance phenomena. These behaviors not only highlight fundamental physics principles but also provide insights into engineering applications like energy harvesting, vibration isolation, and mechanical resonance.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task","text":"","title":"Task"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"Consider the differential equation governing the forced damped pendulum: $$ \\frac{d^2 \\theta}{dt^2} + b \\frac{d \\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) $$ Derive approximate solutions for small-angle oscillations. Explore resonance conditions and their impact on the system\u2019s energy.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"Investigate how the damping coefficient, driving amplitude, and frequency affect the pendulum\u2019s motion. Examine the transition between regular and chaotic motion and its physical interpretations.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Discuss real-world applications of the forced damped pendulum, such as energy harvesting devices, suspension bridges, and oscillating circuits.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"Develop a computational model to simulate the motion of the forced damped pendulum. Visualize behavior under various damping, driving forces, and initial conditions. Plot phase diagrams and Poincar\u00e9 sections to illustrate transitions to chaos.","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#implementation-in-python","text":"( ) Below is a Python implementation using numerical methods to solve the forced damped pendulum equation and visualize its behavior. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # Gravity (m/s^2) L = 1.0 # Length of pendulum (m) b = 0.5 # Damping coefficient A = 1.2 # Driving force amplitude omega = 2.0 # Driving force frequency # Differential equation def forced_damped_pendulum(t, y): theta, omega_t = y dtheta_dt = omega_t domega_dt = - (g / L) * np.sin(theta) - b * omega_t + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Time span and initial conditions t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) y0 = [np.pi / 4, 0] # Initial angle and angular velocity # Solve the differential equation sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Plot results plt.figure(figsize=(10, 5)) plt.plot(sol.t, sol.y[0], label='Theta (rad)') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show() This code numerically solves the forced damped pendulum equation and visualizes the pendulum's motion over time.","title":"Implementation in Python"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#deliverables","text":"A Markdown document with a Python script implementing the simulations. A detailed explanation of the general solutions for the forced damped pendulum. Graphical representations of the motion for different damping coefficients, driving amplitudes, and frequencies, including resonance and chaotic behavior. A discussion on model limitations and potential extensions, such as nonlinear damping or non-periodic driving forces. Phase portraits, Poincar\u00e9 sections, and bifurcation diagrams to analyze transitions to complex dynamics.","title":"Deliverables"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#hints-and-resources","text":"For small angles, approximate \\( \\sin \\theta \\approx \\theta \\) to simplify the equation. Use numerical techniques (e.g., Runge-Kutta methods) to explore dynamics beyond the small-angle approximation. Relate the forced damped pendulum to analogous systems in other fields, such as electrical circuits (driven RLC circuits) or biomechanics (human gait). Utilize software tools like Python for simulations and visualizations. This task bridges theoretical analysis with computational exploration, fostering a deeper understanding of forced and damped oscillatory phenomena and their implications in physics and engineering.","title":"Hints and Resources"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Introduction The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law, is fundamental in celestial mechanics. This law helps determine planetary motions and has implications for understanding gravitational interactions on both local and cosmic scales. Studying this law allows us to predict planetary movements, satellite orbits, and other celestial dynamics with high accuracy. The following sections provide a detailed exploration of the law, its mathematical derivation, and its computational verification through Python simulations. Kepler's Third Law Kepler's Third Law states: $$ T^2 = \\frac{4 \\pi^2 r^3}{G M} $$ where: - \\(T\\) is the orbital period, - \\(r\\) is the orbital radius, - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11}\\) m\u00b3 kg\u207b\u00b9 s\u207b\u00b2), - \\(M\\) is the mass of the central body (e.g., the Sun). Derivation This relationship can be derived from Newton\u2019s law of universal gravitation and circular motion principles. The gravitational force provides the necessary centripetal force to keep an object in orbit: \\[ F = \\frac{G M m}{r^2} = m \\frac{v^2}{r} \\] where \\(m\\) is the mass of the orbiting body, and \\(v\\) is its orbital velocity. Since the velocity is related to the period by: \\[ v = \\frac{2\\pi r}{T} \\] Substituting this into the force equation and solving for \\(T\\) , we obtain Kepler\u2019s Third Law. Implementation in Python The following Python script calculates and visualizes the relationship between orbital period and radius: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) M_earth = 5.972e24 # Mass of the Earth (kg) M_moon = 7.348e22 # Mass of the Moon (kg) # Kepler's Third Law: T^2 = (4 * pi^2 * r^3) / (G * M) def orbital_period(radius, mass=M_sun): return 2 * np.pi * np.sqrt(radius**3 / (G * mass)) # Example: Earth's orbit around the Sun radius_earth_sun = 1.496e11 # meters T_earth = orbital_period(radius_earth_sun) T_earth_years = T_earth / (60 * 60 * 24 * 365.25) # Convert to years print(f\"Orbital period of Earth around the Sun: {T_earth_years:.2f} years\") # Example: Moon's orbit around Earth radius_moon_earth = 3.844e8 # meters T_moon = orbital_period(radius_moon_earth, mass=M_earth) T_moon_days = T_moon / (60 * 60 * 24) # Convert to days print(f\"Orbital period of the Moon around Earth: {T_moon_days:.2f} days\") # Plotting the relationship between orbital radius and period radii = np.linspace(1e10, 5e12, 100) # Different orbital radii in meters periods = orbital_period(radii) / (60 * 60 * 24 * 365.25) # Convert to years plt.figure(figsize=(8, 5)) plt.plot(radii / 1e9, periods, label=\"Kepler's Third Law\") plt.xlabel(\"Orbital Radius (billion meters)\") plt.ylabel(\"Orbital Period (years)\") plt.title(\"Orbital Period vs Orbital Radius\") plt.legend() plt.grid() plt.show() Discussion The plot confirms Kepler's Third Law, showing a clear relationship between orbital radius and period. The calculated values for Earth's orbit around the Sun (~1 year) and the Moon's orbit around Earth (~27 days) align with observed data. The law is crucial in astronomy, helping determine planetary masses, satellite trajectories, and interstellar navigation. This principle extends to elliptical orbits, where the semi-major axis is used instead of a fixed radius. Conclusion Kepler's Third Law provides a crucial link between orbital mechanics and gravitational forces. The Python simulation effectively demonstrates how increasing the orbital radius leads to longer periods, aligning with real-world astronomical observations. Understanding this law allows scientists to make precise calculations about celestial movements, improving our grasp of the universe\u2019s dynamics.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#introduction","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law, is fundamental in celestial mechanics. This law helps determine planetary motions and has implications for understanding gravitational interactions on both local and cosmic scales. Studying this law allows us to predict planetary movements, satellite orbits, and other celestial dynamics with high accuracy. The following sections provide a detailed exploration of the law, its mathematical derivation, and its computational verification through Python simulations.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law","text":"Kepler's Third Law states: $$ T^2 = \\frac{4 \\pi^2 r^3}{G M} $$ where: - \\(T\\) is the orbital period, - \\(r\\) is the orbital radius, - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11}\\) m\u00b3 kg\u207b\u00b9 s\u207b\u00b2), - \\(M\\) is the mass of the central body (e.g., the Sun).","title":"Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation","text":"This relationship can be derived from Newton\u2019s law of universal gravitation and circular motion principles. The gravitational force provides the necessary centripetal force to keep an object in orbit: \\[ F = \\frac{G M m}{r^2} = m \\frac{v^2}{r} \\] where \\(m\\) is the mass of the orbiting body, and \\(v\\) is its orbital velocity. Since the velocity is related to the period by: \\[ v = \\frac{2\\pi r}{T} \\] Substituting this into the force equation and solving for \\(T\\) , we obtain Kepler\u2019s Third Law.","title":"Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implementation-in-python","text":"The following Python script calculates and visualizes the relationship between orbital period and radius: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) M_earth = 5.972e24 # Mass of the Earth (kg) M_moon = 7.348e22 # Mass of the Moon (kg) # Kepler's Third Law: T^2 = (4 * pi^2 * r^3) / (G * M) def orbital_period(radius, mass=M_sun): return 2 * np.pi * np.sqrt(radius**3 / (G * mass)) # Example: Earth's orbit around the Sun radius_earth_sun = 1.496e11 # meters T_earth = orbital_period(radius_earth_sun) T_earth_years = T_earth / (60 * 60 * 24 * 365.25) # Convert to years print(f\"Orbital period of Earth around the Sun: {T_earth_years:.2f} years\") # Example: Moon's orbit around Earth radius_moon_earth = 3.844e8 # meters T_moon = orbital_period(radius_moon_earth, mass=M_earth) T_moon_days = T_moon / (60 * 60 * 24) # Convert to days print(f\"Orbital period of the Moon around Earth: {T_moon_days:.2f} days\") # Plotting the relationship between orbital radius and period radii = np.linspace(1e10, 5e12, 100) # Different orbital radii in meters periods = orbital_period(radii) / (60 * 60 * 24 * 365.25) # Convert to years plt.figure(figsize=(8, 5)) plt.plot(radii / 1e9, periods, label=\"Kepler's Third Law\") plt.xlabel(\"Orbital Radius (billion meters)\") plt.ylabel(\"Orbital Period (years)\") plt.title(\"Orbital Period vs Orbital Radius\") plt.legend() plt.grid() plt.show()","title":"Implementation in Python"},{"location":"1%20Physics/2%20Gravity/Problem_1/#discussion","text":"The plot confirms Kepler's Third Law, showing a clear relationship between orbital radius and period. The calculated values for Earth's orbit around the Sun (~1 year) and the Moon's orbit around Earth (~27 days) align with observed data. The law is crucial in astronomy, helping determine planetary masses, satellite trajectories, and interstellar navigation. This principle extends to elliptical orbits, where the semi-major axis is used instead of a fixed radius.","title":"Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler's Third Law provides a crucial link between orbital mechanics and gravitational forces. The Python simulation effectively demonstrates how increasing the orbital radius leads to longer periods, aligning with real-world astronomical observations. Understanding this law allows scientists to make precise calculations about celestial movements, improving our grasp of the universe\u2019s dynamics.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Introduction Escape velocity is the minimum speed required for an object to break free from the gravitational influence of a celestial body without further propulsion. Cosmic velocities extend this concept, defining different thresholds for orbital motion, escaping the planet, and leaving a star system. Definitions First Cosmic Velocity (Orbital Velocity): The speed required to maintain a circular orbit around a celestial body. Second Cosmic Velocity (Escape Velocity): The speed needed to leave the gravitational pull of a celestial body entirely. Third Cosmic Velocity (Interstellar Escape Velocity): The speed required to escape the gravitational influence of a star system. Mathematical Formulation 1. First Cosmic Velocity: The orbital velocity is given by: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ 2. Second Cosmic Velocity: The escape velocity is calculated using: $$ v_2 = \\sqrt{\\frac{2GM}{R}} $$ 3. Third Cosmic Velocity: Approximated as: $$ v_3 = \\sqrt{\\frac{2GM_{sun}}{R_{orbit}}} $$ Where: - $ G $ is the gravitational constant \\(6.674 \\times 10^{-11} m^3 kg^{-1} s^{-2}\\) - $ M $ is the mass of the celestial body - $ R $ is the radius from the center of the body Python Implementation A separate Python script was used to calculate and visualize the cosmic velocities. The visualization compares the first and second cosmic velocities of Earth, Mars, and Jupiter. The Python script for the graphical representation is as follows: import numpy as np import matplotlib.pyplot as plt def cosmic_velocities(M, R): G = 6.674e-11 # Gravitational constant v1 = np.sqrt(G * M / R) # First cosmic velocity v2 = np.sqrt(2 * G * M / R) # Second cosmic velocity return v1, v2 # Celestial bodies data (mass in kg, radius in meters) bodies = { \"Earth\": (5.972e24, 6.371e6), \"Mars\": (6.417e23, 3.389e6), \"Jupiter\": (1.898e27, 6.9911e7) } # Compute and prepare data for plotting labels = list(bodies.keys()) v1_values, v2_values = zip(*[cosmic_velocities(*bodies[body]) for body in labels]) x = np.arange(len(labels)) width = 0.4 fig, ax = plt.subplots() ax.bar(x - width/2, v1_values, width, label='First Cosmic Velocity') ax.bar(x + width/2, v2_values, width, label='Second Cosmic Velocity') ax.set_xticks(x) ax.set_xticklabels(labels) ax.set_ylabel(\"Velocity (m/s)\") ax.legend() plt.title(\"Cosmic Velocities for Different Celestial Bodies\") plt.show() Conclusion This study illustrates the concepts of escape and cosmic velocities with calculations and visual representations for different celestial bodies. The values computed for Earth, Mars, and Jupiter align with theoretical expectations and emphasize their significance in space exploration.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#introduction","text":"Escape velocity is the minimum speed required for an object to break free from the gravitational influence of a celestial body without further propulsion. Cosmic velocities extend this concept, defining different thresholds for orbital motion, escaping the planet, and leaving a star system.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions","text":"First Cosmic Velocity (Orbital Velocity): The speed required to maintain a circular orbit around a celestial body. Second Cosmic Velocity (Escape Velocity): The speed needed to leave the gravitational pull of a celestial body entirely. Third Cosmic Velocity (Interstellar Escape Velocity): The speed required to escape the gravitational influence of a star system.","title":"Definitions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-formulation","text":"","title":"Mathematical Formulation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity","text":"The orbital velocity is given by: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$","title":"1. First Cosmic Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity","text":"The escape velocity is calculated using: $$ v_2 = \\sqrt{\\frac{2GM}{R}} $$","title":"2. Second Cosmic Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity","text":"Approximated as: $$ v_3 = \\sqrt{\\frac{2GM_{sun}}{R_{orbit}}} $$ Where: - $ G $ is the gravitational constant \\(6.674 \\times 10^{-11} m^3 kg^{-1} s^{-2}\\) - $ M $ is the mass of the celestial body - $ R $ is the radius from the center of the body","title":"3. Third Cosmic Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-implementation","text":"A separate Python script was used to calculate and visualize the cosmic velocities. The visualization compares the first and second cosmic velocities of Earth, Mars, and Jupiter. The Python script for the graphical representation is as follows: import numpy as np import matplotlib.pyplot as plt def cosmic_velocities(M, R): G = 6.674e-11 # Gravitational constant v1 = np.sqrt(G * M / R) # First cosmic velocity v2 = np.sqrt(2 * G * M / R) # Second cosmic velocity return v1, v2 # Celestial bodies data (mass in kg, radius in meters) bodies = { \"Earth\": (5.972e24, 6.371e6), \"Mars\": (6.417e23, 3.389e6), \"Jupiter\": (1.898e27, 6.9911e7) } # Compute and prepare data for plotting labels = list(bodies.keys()) v1_values, v2_values = zip(*[cosmic_velocities(*bodies[body]) for body in labels]) x = np.arange(len(labels)) width = 0.4 fig, ax = plt.subplots() ax.bar(x - width/2, v1_values, width, label='First Cosmic Velocity') ax.bar(x + width/2, v2_values, width, label='Second Cosmic Velocity') ax.set_xticks(x) ax.set_xticklabels(labels) ax.set_ylabel(\"Velocity (m/s)\") ax.legend() plt.title(\"Cosmic Velocities for Different Celestial Bodies\") plt.show()","title":"Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"This study illustrates the concepts of escape and cosmic velocities with calculations and visual representations for different celestial bodies. The values computed for Earth, Mars, and Jupiter align with theoretical expectations and emphasize their significance in space exploration.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This problem blends principles of orbital mechanics and numerical methods. Understanding these trajectories is vital for space missions, such as deploying payloads or returning objects to Earth. Task Analyze the possible trajectories (e.g., parabolic, hyperbolic, elliptical) of a payload released near Earth. Perform a numerical analysis to compute the path of the payload based on given initial conditions (position, velocity, and altitude). Discuss how these trajectories relate to orbital insertion, reentry, or escape scenarios. Develop a computational tool to simulate and visualize the motion of the payload under Earth's gravity. Hints and Resources Use fundamental gravitational principles, such as Newton's Law of Gravitation and Kepler's Laws, to derive equations and analyze scenarios. Leverage numerical methods or software tools (e.g., Python) to simulate orbits and trajectories. Explore real-world applications, such as space mission planning, satellite deployment, and planetary exploration. Implementation Orbital Mechanics The motion of an object under Earth's gravity is governed by Newton's second law: $$ F = \\frac{G M m}{r^2} $$ where: \\(G\\) is the gravitational constant, \\(M\\) is Earth's mass, \\(m\\) is the payload's mass, \\(r\\) is the distance from Earth's center. Depending on the object's velocity, different types of trajectories occur: Elliptical (Bound Orbit) : Velocity is below escape velocity. Parabolic (Escape Trajectory) : Velocity equals escape velocity. Hyperbolic (Unbound Escape) : Velocity exceeds escape velocity. Python Code Version of the Simulation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R = 6371000 # Radius of Earth (m) def equations(t, y): x, vx, y, vy = y r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, ax, vy, ay] # Initial conditions (position and velocity) x0, y0 = R + 500000, 0 # 500 km altitude vx0, vy0 = 0, 7500 # Approximate orbital velocity (m/s) y_init = [x0, vx0, y0, vy0] t_span = (0, 10000) # Time span for simulation (seconds) t_eval = np.linspace(0, 10000, 1000) sol = solve_ivp(equations, t_span, y_init, t_eval=t_eval, method='RK45') # Plot the trajectory plt.figure(figsize=(6,6)) plt.plot(sol.y[0], sol.y[2], label='Payload Trajectory') plt.scatter(0, 0, color='blue', label='Earth', s=100) plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.legend() plt.title('Simulated Payload Trajectory') plt.grid() plt.show()","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This problem blends principles of orbital mechanics and numerical methods. Understanding these trajectories is vital for space missions, such as deploying payloads or returning objects to Earth.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task","text":"Analyze the possible trajectories (e.g., parabolic, hyperbolic, elliptical) of a payload released near Earth. Perform a numerical analysis to compute the path of the payload based on given initial conditions (position, velocity, and altitude). Discuss how these trajectories relate to orbital insertion, reentry, or escape scenarios. Develop a computational tool to simulate and visualize the motion of the payload under Earth's gravity.","title":"Task"},{"location":"1%20Physics/2%20Gravity/Problem_3/#hints-and-resources","text":"Use fundamental gravitational principles, such as Newton's Law of Gravitation and Kepler's Laws, to derive equations and analyze scenarios. Leverage numerical methods or software tools (e.g., Python) to simulate orbits and trajectories. Explore real-world applications, such as space mission planning, satellite deployment, and planetary exploration.","title":"Hints and Resources"},{"location":"1%20Physics/2%20Gravity/Problem_3/#implementation","text":"","title":"Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-mechanics","text":"The motion of an object under Earth's gravity is governed by Newton's second law: $$ F = \\frac{G M m}{r^2} $$ where: \\(G\\) is the gravitational constant, \\(M\\) is Earth's mass, \\(m\\) is the payload's mass, \\(r\\) is the distance from Earth's center. Depending on the object's velocity, different types of trajectories occur: Elliptical (Bound Orbit) : Velocity is below escape velocity. Parabolic (Escape Trajectory) : Velocity equals escape velocity. Hyperbolic (Unbound Escape) : Velocity exceeds escape velocity.","title":"Orbital Mechanics"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-version-of-the-simulation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R = 6371000 # Radius of Earth (m) def equations(t, y): x, vx, y, vy = y r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, ax, vy, ay] # Initial conditions (position and velocity) x0, y0 = R + 500000, 0 # 500 km altitude vx0, vy0 = 0, 7500 # Approximate orbital velocity (m/s) y_init = [x0, vx0, y0, vy0] t_span = (0, 10000) # Time span for simulation (seconds) t_eval = np.linspace(0, 10000, 1000) sol = solve_ivp(equations, t_span, y_init, t_eval=t_eval, method='RK45') # Plot the trajectory plt.figure(figsize=(6,6)) plt.plot(sol.y[0], sol.y[2], label='Payload Trajectory') plt.scatter(0, 0, color='blue', label='Earth', s=100) plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.legend() plt.title('Simulated Payload Trajectory') plt.grid() plt.show()","title":"Python Code Version of the Simulation"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface Motivation Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be observed when ripples from different points meet, forming distinctive interference patterns. These patterns help us understand wave behavior and the relationship between wave phase and multiple sources. Task A circular wave on the water surface, emanating from a point source located at (x_0, y_0), can be described by the equation: \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) where: - \\eta(x, y, t) is the displacement at (x, y) and time. - - A is the amplitude. - - k = \\frac{2\\pi}{\\lambda} $ is the wave number. - - \\omega = 2\\pi f is the angular frequency. - - r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} is the distance from the source. - - \\phi is the initial phase. Problem Statement Analyze the interference patterns formed on the water surface due to the superposition of waves emitted from sources placed at the vertices of a regular polygon. Steps to Follow Select a Regular Polygon : Choose a regular polygon (triangle, square, pentagon, etc.). Position the Sources : Place wave sources at the vertices. Wave Equations : Define the wave equation for each source. Superposition of Waves : Sum the wave displacements at each point: $$ \\eta_{sum}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) $$ Analyze Interference Patterns : Identify constructive and destructive interference regions. Visualization : Use Python and Matplotlib to graphically illustrate the patterns. Considerations Assume all sources emit waves with the same A, \\lambda, and f . The waves are coherent with a constant phase difference. Use Python for simulations and visualizations. Deliverables A Markdown document with detailed theoretical explanations and equations. A Python script implementing the simulation. Graphical representations showing constructive and destructive interference regions. Python Code Implementation import numpy as np import matplotlib.pyplot as plt # Define parameters A = 1 # Amplitude wavelength = 1 # Wavelength k = 2 * np.pi / wavelength # Wave number f = 1 # Frequency omega = 2 * np.pi * f # Angular frequency phi = 0 # Initial phase def wave(x, y, x0, y0, t): r = np.sqrt((x - x0)**2 + (y - y0)**2) return (A / np.sqrt(r + 1e-6)) * np.cos(k * r - omega * t + phi) # Define polygon sources N = 4 # Number of sources (square) radius = 5 # Radius of the polygon angles = np.linspace(0, 2 * np.pi, N, endpoint=False) source_positions = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Grid setup x_vals = np.linspace(-10, 10, 200) y_vals = np.linspace(-10, 10, 200) x, y = np.meshgrid(x_vals, y_vals) def total_wave(x, y, t): sum_wave = np.zeros_like(x) for x0, y0 in source_positions: sum_wave += wave(x, y, x0, y0, t) return sum_wave # Plot result t = 0 plt.figure(figsize=(8, 8)) plt.contourf(x, y, total_wave(x, y, t), levels=100, cmap='inferno') plt.colorbar(label='Wave Amplitude') plt.scatter(*zip(*source_positions), color='white', marker='o', label='Wave Sources') plt.legend() plt.title('Interference Pattern from a Square Wave Source') plt.xlabel('X') plt.ylabel('Y') plt.show() This script simulates interference patterns for a square wave source. Modify \\(N\\) and \\(radius\\) to explore different polygons. Conclusion This project provides insight into wave interference by simulating patterns from multiple sources. By visualizing the wave superposition, we can better understand constructive and destructive interference effects.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be observed when ripples from different points meet, forming distinctive interference patterns. These patterns help us understand wave behavior and the relationship between wave phase and multiple sources.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#task","text":"A circular wave on the water surface, emanating from a point source located at (x_0, y_0), can be described by the equation: \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) where: - \\eta(x, y, t) is the displacement at (x, y) and time. - - A is the amplitude. - - k = \\frac{2\\pi}{\\lambda} $ is the wave number. - - \\omega = 2\\pi f is the angular frequency. - - r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} is the distance from the source. - - \\phi is the initial phase.","title":"Task"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-statement","text":"Analyze the interference patterns formed on the water surface due to the superposition of waves emitted from sources placed at the vertices of a regular polygon.","title":"Problem Statement"},{"location":"1%20Physics/3%20Waves/Problem_1/#steps-to-follow","text":"Select a Regular Polygon : Choose a regular polygon (triangle, square, pentagon, etc.). Position the Sources : Place wave sources at the vertices. Wave Equations : Define the wave equation for each source. Superposition of Waves : Sum the wave displacements at each point: $$ \\eta_{sum}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) $$ Analyze Interference Patterns : Identify constructive and destructive interference regions. Visualization : Use Python and Matplotlib to graphically illustrate the patterns.","title":"Steps to Follow"},{"location":"1%20Physics/3%20Waves/Problem_1/#considerations","text":"Assume all sources emit waves with the same A, \\lambda, and f . The waves are coherent with a constant phase difference. Use Python for simulations and visualizations.","title":"Considerations"},{"location":"1%20Physics/3%20Waves/Problem_1/#deliverables","text":"A Markdown document with detailed theoretical explanations and equations. A Python script implementing the simulation. Graphical representations showing constructive and destructive interference regions.","title":"Deliverables"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-code-implementation","text":"import numpy as np import matplotlib.pyplot as plt # Define parameters A = 1 # Amplitude wavelength = 1 # Wavelength k = 2 * np.pi / wavelength # Wave number f = 1 # Frequency omega = 2 * np.pi * f # Angular frequency phi = 0 # Initial phase def wave(x, y, x0, y0, t): r = np.sqrt((x - x0)**2 + (y - y0)**2) return (A / np.sqrt(r + 1e-6)) * np.cos(k * r - omega * t + phi) # Define polygon sources N = 4 # Number of sources (square) radius = 5 # Radius of the polygon angles = np.linspace(0, 2 * np.pi, N, endpoint=False) source_positions = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Grid setup x_vals = np.linspace(-10, 10, 200) y_vals = np.linspace(-10, 10, 200) x, y = np.meshgrid(x_vals, y_vals) def total_wave(x, y, t): sum_wave = np.zeros_like(x) for x0, y0 in source_positions: sum_wave += wave(x, y, x0, y0, t) return sum_wave # Plot result t = 0 plt.figure(figsize=(8, 8)) plt.contourf(x, y, total_wave(x, y, t), levels=100, cmap='inferno') plt.colorbar(label='Wave Amplitude') plt.scatter(*zip(*source_positions), color='white', marker='o', label='Wave Sources') plt.legend() plt.title('Interference Pattern from a Square Wave Source') plt.xlabel('X') plt.ylabel('Y') plt.show() This script simulates interference patterns for a square wave source. Modify \\(N\\) and \\(radius\\) to explore different polygons.","title":"Python Code Implementation"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"This project provides insight into wave interference by simulating patterns from multiple sources. By visualizing the wave superposition, we can better understand constructive and destructive interference effects.","title":"Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}