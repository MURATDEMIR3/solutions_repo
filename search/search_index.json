{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Motivation Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. Yet, beneath this simplicity lies a complex and versatile framework. The equations governing projectile motion involve both linear and quadratic relationships, making them accessible yet deeply insightful. What makes this topic particularly compelling is the number of free parameters involved in these equations, such as initial velocity, gravitational acceleration, and launch height. These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket. Task 1. Theoretical Foundation Begin by deriving the governing equations of motion from fundamental principles. This involves solving a basic differential equation to establish the general form of the motion. Highlight how variations in initial conditions lead to a family of solutions. 2. Analysis of the Range Investigate how the horizontal range depends on the angle of projection. Discuss how changes in other parameters, such as initial velocity and gravitational acceleration, influence the relationship. 3. Practical Applications Reflect on how this model can be adapted to describe various real-world situations, such as projectiles launched on uneven terrain or in the presence of air resistance. 4. Implementation Develop a computational tool or algorithm to simulate projectile motion. Visualize the range as a function of the angle of projection for different sets of initial conditions. Theoretical Solutions The equations of motion governing projectile motion are given by: \\[ x(t) = v_0 \\cos(\\theta) t \\] \\[ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] The total time of flight is: \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\] The range of the projectile is: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] The maximum height reached is: \\[ H = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\] Python Code for Simulation import numpy as np def projectile_range(v0, theta, g=9.81): \"\"\"Compute the range of a projectile given initial velocity and launch angle.\"\"\" theta_rad = np.radians(theta) return (v0**2 * np.sin(2 * theta_rad)) / g # Parameters v0 = 20 # Initial velocity in m/s theta_values = np.linspace(0, 90, num=100) # Angle range from 0 to 90 degrees ranges = [projectile_range(v0, theta) for theta in theta_values] Deliverables A Markdown document with Python script or notebook implementing the simulations. A detailed description of the family of solutions derived from the governing equations. Graphical representations of the range versus angle of projection, highlighting how different parameters influence the curve. A discussion on the limitations of the idealized model and suggestions for incorporating more realistic factors, such as drag or wind. Hints and Resources Start from the fundamental laws of motion and gradually build the general solution. Use numerical methods or simulation tools to explore scenarios that go beyond simple analytical solutions. Consider how this model connects to real-world systems, such as sports, engineering, and astrophysics. This task encourages a deep understanding of projectile motion while showcasing its versatility and applicability across various domains.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. Yet, beneath this simplicity lies a complex and versatile framework. The equations governing projectile motion involve both linear and quadratic relationships, making them accessible yet deeply insightful. What makes this topic particularly compelling is the number of free parameters involved in these equations, such as initial velocity, gravitational acceleration, and launch height. These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#task","text":"","title":"Task"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Begin by deriving the governing equations of motion from fundamental principles. This involves solving a basic differential equation to establish the general form of the motion. Highlight how variations in initial conditions lead to a family of solutions.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"Investigate how the horizontal range depends on the angle of projection. Discuss how changes in other parameters, such as initial velocity and gravitational acceleration, influence the relationship.","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Reflect on how this model can be adapted to describe various real-world situations, such as projectiles launched on uneven terrain or in the presence of air resistance.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"Develop a computational tool or algorithm to simulate projectile motion. Visualize the range as a function of the angle of projection for different sets of initial conditions.","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#theoretical-solutions","text":"The equations of motion governing projectile motion are given by: \\[ x(t) = v_0 \\cos(\\theta) t \\] \\[ y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] The total time of flight is: \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\] The range of the projectile is: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] The maximum height reached is: \\[ H = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\]","title":"Theoretical Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code-for-simulation","text":"import numpy as np def projectile_range(v0, theta, g=9.81): \"\"\"Compute the range of a projectile given initial velocity and launch angle.\"\"\" theta_rad = np.radians(theta) return (v0**2 * np.sin(2 * theta_rad)) / g # Parameters v0 = 20 # Initial velocity in m/s theta_values = np.linspace(0, 90, num=100) # Angle range from 0 to 90 degrees ranges = [projectile_range(v0, theta) for theta in theta_values]","title":"Python Code for Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#deliverables","text":"A Markdown document with Python script or notebook implementing the simulations. A detailed description of the family of solutions derived from the governing equations. Graphical representations of the range versus angle of projection, highlighting how different parameters influence the curve. A discussion on the limitations of the idealized model and suggestions for incorporating more realistic factors, such as drag or wind.","title":"Deliverables"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#hints-and-resources","text":"Start from the fundamental laws of motion and gradually build the general solution. Use numerical methods or simulation tools to explore scenarios that go beyond simple analytical solutions. Consider how this model connects to real-world systems, such as sports, engineering, and astrophysics. This task encourages a deep understanding of projectile motion while showcasing its versatility and applicability across various domains.","title":"Hints and Resources"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is an intriguing physical system exhibiting complex behaviors due to the interplay of damping, restoring forces, and external periodic forcing. By introducing both damping and external forcing, the system transitions from simple harmonic motion to a spectrum of dynamics, including resonance, chaos, and quasiperiodic motion. These phenomena help in understanding real-world applications such as driven oscillators, climate systems, and mechanical structures under periodic stress. Forcing introduces new parameters, such as amplitude and frequency of the external force, significantly influencing the pendulum\u2019s behavior. By systematically varying these parameters, diverse solutions emerge, including synchronized oscillations, chaotic motion, and resonance phenomena. These behaviors not only highlight fundamental physics principles but also provide insights into engineering applications like energy harvesting, vibration isolation, and mechanical resonance. Task 1. Theoretical Foundation Consider the differential equation governing the forced damped pendulum: $$ \\frac{d^2 \\theta}{dt^2} + b \\frac{d \\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) $$ Derive approximate solutions for small-angle oscillations. Explore resonance conditions and their impact on the system\u2019s energy. 2. Analysis of Dynamics Investigate how the damping coefficient, driving amplitude, and frequency affect the pendulum\u2019s motion. Examine the transition between regular and chaotic motion and its physical interpretations. 3. Practical Applications Discuss real-world applications of the forced damped pendulum, such as energy harvesting devices, suspension bridges, and oscillating circuits. 4. Implementation Develop a computational model to simulate the motion of the forced damped pendulum. Visualize behavior under various damping, driving forces, and initial conditions. Plot phase diagrams and Poincar\u00e9 sections to illustrate transitions to chaos. Implementation in Python ( ) Below is a Python implementation using numerical methods to solve the forced damped pendulum equation and visualize its behavior. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # Gravity (m/s^2) L = 1.0 # Length of pendulum (m) b = 0.5 # Damping coefficient A = 1.2 # Driving force amplitude omega = 2.0 # Driving force frequency # Differential equation def forced_damped_pendulum(t, y): theta, omega_t = y dtheta_dt = omega_t domega_dt = - (g / L) * np.sin(theta) - b * omega_t + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Time span and initial conditions t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) y0 = [np.pi / 4, 0] # Initial angle and angular velocity # Solve the differential equation sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Plot results plt.figure(figsize=(10, 5)) plt.plot(sol.t, sol.y[0], label='Theta (rad)') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show() This code numerically solves the forced damped pendulum equation and visualizes the pendulum's motion over time. Deliverables A Markdown document with a Python script implementing the simulations. A detailed explanation of the general solutions for the forced damped pendulum. Graphical representations of the motion for different damping coefficients, driving amplitudes, and frequencies, including resonance and chaotic behavior. A discussion on model limitations and potential extensions, such as nonlinear damping or non-periodic driving forces. Phase portraits, Poincar\u00e9 sections, and bifurcation diagrams to analyze transitions to complex dynamics. Hints and Resources For small angles, approximate \\( \\sin \\theta \\approx \\theta \\) to simplify the equation. Use numerical techniques (e.g., Runge-Kutta methods) to explore dynamics beyond the small-angle approximation. Relate the forced damped pendulum to analogous systems in other fields, such as electrical circuits (driven RLC circuits) or biomechanics (human gait). Utilize software tools like Python for simulations and visualizations. This task bridges theoretical analysis with computational exploration, fostering a deeper understanding of forced and damped oscillatory phenomena and their implications in physics and engineering.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is an intriguing physical system exhibiting complex behaviors due to the interplay of damping, restoring forces, and external periodic forcing. By introducing both damping and external forcing, the system transitions from simple harmonic motion to a spectrum of dynamics, including resonance, chaos, and quasiperiodic motion. These phenomena help in understanding real-world applications such as driven oscillators, climate systems, and mechanical structures under periodic stress. Forcing introduces new parameters, such as amplitude and frequency of the external force, significantly influencing the pendulum\u2019s behavior. By systematically varying these parameters, diverse solutions emerge, including synchronized oscillations, chaotic motion, and resonance phenomena. These behaviors not only highlight fundamental physics principles but also provide insights into engineering applications like energy harvesting, vibration isolation, and mechanical resonance.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task","text":"","title":"Task"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"Consider the differential equation governing the forced damped pendulum: $$ \\frac{d^2 \\theta}{dt^2} + b \\frac{d \\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) $$ Derive approximate solutions for small-angle oscillations. Explore resonance conditions and their impact on the system\u2019s energy.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"Investigate how the damping coefficient, driving amplitude, and frequency affect the pendulum\u2019s motion. Examine the transition between regular and chaotic motion and its physical interpretations.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Discuss real-world applications of the forced damped pendulum, such as energy harvesting devices, suspension bridges, and oscillating circuits.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"Develop a computational model to simulate the motion of the forced damped pendulum. Visualize behavior under various damping, driving forces, and initial conditions. Plot phase diagrams and Poincar\u00e9 sections to illustrate transitions to chaos.","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#implementation-in-python","text":"( ) Below is a Python implementation using numerical methods to solve the forced damped pendulum equation and visualize its behavior. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # Gravity (m/s^2) L = 1.0 # Length of pendulum (m) b = 0.5 # Damping coefficient A = 1.2 # Driving force amplitude omega = 2.0 # Driving force frequency # Differential equation def forced_damped_pendulum(t, y): theta, omega_t = y dtheta_dt = omega_t domega_dt = - (g / L) * np.sin(theta) - b * omega_t + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Time span and initial conditions t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) y0 = [np.pi / 4, 0] # Initial angle and angular velocity # Solve the differential equation sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Plot results plt.figure(figsize=(10, 5)) plt.plot(sol.t, sol.y[0], label='Theta (rad)') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show() This code numerically solves the forced damped pendulum equation and visualizes the pendulum's motion over time.","title":"Implementation in Python"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#deliverables","text":"A Markdown document with a Python script implementing the simulations. A detailed explanation of the general solutions for the forced damped pendulum. Graphical representations of the motion for different damping coefficients, driving amplitudes, and frequencies, including resonance and chaotic behavior. A discussion on model limitations and potential extensions, such as nonlinear damping or non-periodic driving forces. Phase portraits, Poincar\u00e9 sections, and bifurcation diagrams to analyze transitions to complex dynamics.","title":"Deliverables"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#hints-and-resources","text":"For small angles, approximate \\( \\sin \\theta \\approx \\theta \\) to simplify the equation. Use numerical techniques (e.g., Runge-Kutta methods) to explore dynamics beyond the small-angle approximation. Relate the forced damped pendulum to analogous systems in other fields, such as electrical circuits (driven RLC circuits) or biomechanics (human gait). Utilize software tools like Python for simulations and visualizations. This task bridges theoretical analysis with computational exploration, fostering a deeper understanding of forced and damped oscillatory phenomena and their implications in physics and engineering.","title":"Hints and Resources"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Introduction The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law, is fundamental in celestial mechanics. This law helps determine planetary motions and has implications for understanding gravitational interactions on both local and cosmic scales. Studying this law allows us to predict planetary movements, satellite orbits, and other celestial dynamics with high accuracy. The following sections provide a detailed exploration of the law, its mathematical derivation, and its computational verification through Python simulations. Kepler's Third Law Kepler's Third Law states: $$ T^2 = \\frac{4 \\pi^2 r^3}{G M} $$ where: - \\(T\\) is the orbital period, - \\(r\\) is the orbital radius, - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11}\\) m\u00b3 kg\u207b\u00b9 s\u207b\u00b2), - \\(M\\) is the mass of the central body (e.g., the Sun). Derivation This relationship can be derived from Newton\u2019s law of universal gravitation and circular motion principles. The gravitational force provides the necessary centripetal force to keep an object in orbit: \\[ F = \\frac{G M m}{r^2} = m \\frac{v^2}{r} \\] where \\(m\\) is the mass of the orbiting body, and \\(v\\) is its orbital velocity. Since the velocity is related to the period by: \\[ v = \\frac{2\\pi r}{T} \\] Substituting this into the force equation and solving for \\(T\\) , we obtain Kepler\u2019s Third Law. Implementation in Python The following Python script calculates and visualizes the relationship between orbital period and radius: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) M_earth = 5.972e24 # Mass of the Earth (kg) M_moon = 7.348e22 # Mass of the Moon (kg) # Kepler's Third Law: T^2 = (4 * pi^2 * r^3) / (G * M) def orbital_period(radius, mass=M_sun): return 2 * np.pi * np.sqrt(radius**3 / (G * mass)) # Example: Earth's orbit around the Sun radius_earth_sun = 1.496e11 # meters T_earth = orbital_period(radius_earth_sun) T_earth_years = T_earth / (60 * 60 * 24 * 365.25) # Convert to years print(f\"Orbital period of Earth around the Sun: {T_earth_years:.2f} years\") # Example: Moon's orbit around Earth radius_moon_earth = 3.844e8 # meters T_moon = orbital_period(radius_moon_earth, mass=M_earth) T_moon_days = T_moon / (60 * 60 * 24) # Convert to days print(f\"Orbital period of the Moon around Earth: {T_moon_days:.2f} days\") # Plotting the relationship between orbital radius and period radii = np.linspace(1e10, 5e12, 100) # Different orbital radii in meters periods = orbital_period(radii) / (60 * 60 * 24 * 365.25) # Convert to years plt.figure(figsize=(8, 5)) plt.plot(radii / 1e9, periods, label=\"Kepler's Third Law\") plt.xlabel(\"Orbital Radius (billion meters)\") plt.ylabel(\"Orbital Period (years)\") plt.title(\"Orbital Period vs Orbital Radius\") plt.legend() plt.grid() plt.show() Discussion The plot confirms Kepler's Third Law, showing a clear relationship between orbital radius and period. The calculated values for Earth's orbit around the Sun (~1 year) and the Moon's orbit around Earth (~27 days) align with observed data. The law is crucial in astronomy, helping determine planetary masses, satellite trajectories, and interstellar navigation. This principle extends to elliptical orbits, where the semi-major axis is used instead of a fixed radius. Conclusion Kepler's Third Law provides a crucial link between orbital mechanics and gravitational forces. The Python simulation effectively demonstrates how increasing the orbital radius leads to longer periods, aligning with real-world astronomical observations. Understanding this law allows scientists to make precise calculations about celestial movements, improving our grasp of the universe\u2019s dynamics.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#introduction","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law, is fundamental in celestial mechanics. This law helps determine planetary motions and has implications for understanding gravitational interactions on both local and cosmic scales. Studying this law allows us to predict planetary movements, satellite orbits, and other celestial dynamics with high accuracy. The following sections provide a detailed exploration of the law, its mathematical derivation, and its computational verification through Python simulations.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law","text":"Kepler's Third Law states: $$ T^2 = \\frac{4 \\pi^2 r^3}{G M} $$ where: - \\(T\\) is the orbital period, - \\(r\\) is the orbital radius, - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11}\\) m\u00b3 kg\u207b\u00b9 s\u207b\u00b2), - \\(M\\) is the mass of the central body (e.g., the Sun).","title":"Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation","text":"This relationship can be derived from Newton\u2019s law of universal gravitation and circular motion principles. The gravitational force provides the necessary centripetal force to keep an object in orbit: \\[ F = \\frac{G M m}{r^2} = m \\frac{v^2}{r} \\] where \\(m\\) is the mass of the orbiting body, and \\(v\\) is its orbital velocity. Since the velocity is related to the period by: \\[ v = \\frac{2\\pi r}{T} \\] Substituting this into the force equation and solving for \\(T\\) , we obtain Kepler\u2019s Third Law.","title":"Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implementation-in-python","text":"The following Python script calculates and visualizes the relationship between orbital period and radius: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) M_earth = 5.972e24 # Mass of the Earth (kg) M_moon = 7.348e22 # Mass of the Moon (kg) # Kepler's Third Law: T^2 = (4 * pi^2 * r^3) / (G * M) def orbital_period(radius, mass=M_sun): return 2 * np.pi * np.sqrt(radius**3 / (G * mass)) # Example: Earth's orbit around the Sun radius_earth_sun = 1.496e11 # meters T_earth = orbital_period(radius_earth_sun) T_earth_years = T_earth / (60 * 60 * 24 * 365.25) # Convert to years print(f\"Orbital period of Earth around the Sun: {T_earth_years:.2f} years\") # Example: Moon's orbit around Earth radius_moon_earth = 3.844e8 # meters T_moon = orbital_period(radius_moon_earth, mass=M_earth) T_moon_days = T_moon / (60 * 60 * 24) # Convert to days print(f\"Orbital period of the Moon around Earth: {T_moon_days:.2f} days\") # Plotting the relationship between orbital radius and period radii = np.linspace(1e10, 5e12, 100) # Different orbital radii in meters periods = orbital_period(radii) / (60 * 60 * 24 * 365.25) # Convert to years plt.figure(figsize=(8, 5)) plt.plot(radii / 1e9, periods, label=\"Kepler's Third Law\") plt.xlabel(\"Orbital Radius (billion meters)\") plt.ylabel(\"Orbital Period (years)\") plt.title(\"Orbital Period vs Orbital Radius\") plt.legend() plt.grid() plt.show()","title":"Implementation in Python"},{"location":"1%20Physics/2%20Gravity/Problem_1/#discussion","text":"The plot confirms Kepler's Third Law, showing a clear relationship between orbital radius and period. The calculated values for Earth's orbit around the Sun (~1 year) and the Moon's orbit around Earth (~27 days) align with observed data. The law is crucial in astronomy, helping determine planetary masses, satellite trajectories, and interstellar navigation. This principle extends to elliptical orbits, where the semi-major axis is used instead of a fixed radius.","title":"Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler's Third Law provides a crucial link between orbital mechanics and gravitational forces. The Python simulation effectively demonstrates how increasing the orbital radius leads to longer periods, aligning with real-world astronomical observations. Understanding this law allows scientists to make precise calculations about celestial movements, improving our grasp of the universe\u2019s dynamics.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Motivation The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. Tasks Define the first, second, and third cosmic velocities, explaining their physical meaning. Analyze the mathematical derivations and parameters affecting these velocities. Calculate and visualize these velocities for different celestial bodies like Earth, Mars, and Jupiter. Discuss their importance in space exploration, including launching satellites, missions to other planets, and potential interstellar travel. Deliverables A Markdown document with Python script or notebook implementing the simulations. A detailed explanation of the subjects. Graphical representations of escape velocities and cosmic velocities for various celestial bodies. Theoretical Background What is Escape Velocity? Escape velocity is the minimum speed needed for an object to break free from the gravitational pull of a celestial body without further propulsion. Formula: \\[ v_e = \\sqrt{\\frac{2GM}{r}} \\] Where: \\(G\\) is the gravitational constant \\(6.674 \\times 10^{-11}\\, \\text{Nm}^2/\\text{kg}^2\\) \\(M\\) is the mass of the celestial body \\(r\\) is the radius from the center of mass The Cosmic Velocities 1. First Cosmic Velocity \u2014 Orbital Speed \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] 2. Second Cosmic Velocity \u2014 Escape Speed \\[ v_2 = \\sqrt{2} \\cdot v_1 \\] 3. Third Cosmic Velocity \u2014 Interstellar Escape \\[ v_3 = \\sqrt{v_{\\text{earth orbit}}^2 + v_{\\text{sun escape}}^2} \\] Python Simulation of Cosmic Velocities import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 # Gravitational constant # Celestial body data: (mass in kg, radius in meters) bodies = { \"Earth\": (5.972e24, 6.371e6), \"Mars\": (6.39e23, 3.3895e6), \"Jupiter\": (1.898e27, 6.9911e7) } def velocities(mass, radius): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2) * v1 return v1, v2 for name, (mass, radius) in bodies.items(): v1, v2 = velocities(mass, radius) print(f\"{name}: First Cosmic Velocity = {v1/1000:.2f} km/s, Second Cosmic Velocity = {v2/1000:.2f} km/s\") Visualization labels = [] v1_list = [] v2_list = [] for name, (mass, radius) in bodies.items(): v1, v2 = velocities(mass, radius) labels.append(name) v1_list.append(v1 / 1000) v2_list.append(v2 / 1000) x = np.arange(len(labels)) width = 0.35 fig, ax = plt.subplots() ax.bar(x - width/2, v1_list, width, label='First Cosmic Velocity') ax.bar(x + width/2, v2_list, width, label='Second Cosmic Velocity') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.grid(True) plt.tight_layout() plt.show() Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario blends principles of orbital mechanics and numerical methods. Tasks Analyze the possible trajectories (parabolic, hyperbolic, elliptical) of a payload released near Earth. Perform a numerical analysis to compute the path based on initial conditions (position, velocity, and altitude). Discuss how these trajectories relate to orbital insertion, reentry, or escape scenarios. Develop a computational tool to simulate and visualize the motion of the payload under Earth's gravity. Python Simulation of Trajectory import matplotlib.pyplot as plt from scipy.integrate import solve_ivp import numpy as np G = 6.67430e-11 M = 5.972e24 R = 6.371e6 # Earth radius def trajectory(t, y): x, vx, y_, vy = y r = np.sqrt(x**2 + y_**2) ax = -G * M * x / r**3 ay = -G * M * y_ / r**3 return [vx, ax, vy, ay] initial_state = [R + 1000, 0, 0, 7800] # 1 km above Earth, 7.8 km/s speed t_span = (0, 6000) t_eval = np.linspace(*t_span, 1000) solution = solve_ivp(trajectory, t_span, initial_state, t_eval=t_eval) plt.plot(solution.y[0], solution.y[2]) plt.xlabel(\"x position (m)\") plt.ylabel(\"y position (m)\") plt.title(\"Payload Trajectory Near Earth\") plt.axis('equal') plt.grid(True) plt.show() Hints and Resources Use fundamental gravitational principles: Newton\u2019s Law of Gravitation and Kepler\u2019s Laws. Leverage numerical tools (Python) to simulate orbits and trajectories. Apply to space mission planning, satellite deployment, and planetary exploration. Deliverables Summary Clean Markdown document ready for Visual Studio & GitHub. All physical explanations and mathematical derivations. Full Python code for simulation and visualization. Graphs for escape velocities and orbital trajectories. Conclusion This project provides a strong foundation for understanding how gravity governs motion and escape conditions in space. From satellite launches to deep space missions, the principles explored here are critical in real-world aerospace engineering.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#tasks","text":"Define the first, second, and third cosmic velocities, explaining their physical meaning. Analyze the mathematical derivations and parameters affecting these velocities. Calculate and visualize these velocities for different celestial bodies like Earth, Mars, and Jupiter. Discuss their importance in space exploration, including launching satellites, missions to other planets, and potential interstellar travel.","title":"Tasks"},{"location":"1%20Physics/2%20Gravity/Problem_2/#deliverables","text":"A Markdown document with Python script or notebook implementing the simulations. A detailed explanation of the subjects. Graphical representations of escape velocities and cosmic velocities for various celestial bodies.","title":"Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_2/#theoretical-background","text":"","title":"Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_2/#what-is-escape-velocity","text":"Escape velocity is the minimum speed needed for an object to break free from the gravitational pull of a celestial body without further propulsion. Formula: \\[ v_e = \\sqrt{\\frac{2GM}{r}} \\] Where: \\(G\\) is the gravitational constant \\(6.674 \\times 10^{-11}\\, \\text{Nm}^2/\\text{kg}^2\\) \\(M\\) is the mass of the celestial body \\(r\\) is the radius from the center of mass","title":"What is Escape Velocity?"},{"location":"1%20Physics/2%20Gravity/Problem_2/#the-cosmic-velocities","text":"","title":"The Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-orbital-speed","text":"\\[ v_1 = \\sqrt{\\frac{GM}{r}} \\]","title":"1. First Cosmic Velocity \u2014 Orbital Speed"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-speed","text":"\\[ v_2 = \\sqrt{2} \\cdot v_1 \\]","title":"2. Second Cosmic Velocity \u2014 Escape Speed"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-interstellar-escape","text":"\\[ v_3 = \\sqrt{v_{\\text{earth orbit}}^2 + v_{\\text{sun escape}}^2} \\]","title":"3. Third Cosmic Velocity \u2014 Interstellar Escape"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-simulation-of-cosmic-velocities","text":"import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 # Gravitational constant # Celestial body data: (mass in kg, radius in meters) bodies = { \"Earth\": (5.972e24, 6.371e6), \"Mars\": (6.39e23, 3.3895e6), \"Jupiter\": (1.898e27, 6.9911e7) } def velocities(mass, radius): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2) * v1 return v1, v2 for name, (mass, radius) in bodies.items(): v1, v2 = velocities(mass, radius) print(f\"{name}: First Cosmic Velocity = {v1/1000:.2f} km/s, Second Cosmic Velocity = {v2/1000:.2f} km/s\")","title":"Python Simulation of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#visualization","text":"labels = [] v1_list = [] v2_list = [] for name, (mass, radius) in bodies.items(): v1, v2 = velocities(mass, radius) labels.append(name) v1_list.append(v1 / 1000) v2_list.append(v2 / 1000) x = np.arange(len(labels)) width = 0.35 fig, ax = plt.subplots() ax.bar(x - width/2, v1_list, width, label='First Cosmic Velocity') ax.bar(x + width/2, v2_list, width, label='Second Cosmic Velocity') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation_1","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario blends principles of orbital mechanics and numerical methods.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#tasks_1","text":"Analyze the possible trajectories (parabolic, hyperbolic, elliptical) of a payload released near Earth. Perform a numerical analysis to compute the path based on initial conditions (position, velocity, and altitude). Discuss how these trajectories relate to orbital insertion, reentry, or escape scenarios. Develop a computational tool to simulate and visualize the motion of the payload under Earth's gravity.","title":"Tasks"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-simulation-of-trajectory","text":"import matplotlib.pyplot as plt from scipy.integrate import solve_ivp import numpy as np G = 6.67430e-11 M = 5.972e24 R = 6.371e6 # Earth radius def trajectory(t, y): x, vx, y_, vy = y r = np.sqrt(x**2 + y_**2) ax = -G * M * x / r**3 ay = -G * M * y_ / r**3 return [vx, ax, vy, ay] initial_state = [R + 1000, 0, 0, 7800] # 1 km above Earth, 7.8 km/s speed t_span = (0, 6000) t_eval = np.linspace(*t_span, 1000) solution = solve_ivp(trajectory, t_span, initial_state, t_eval=t_eval) plt.plot(solution.y[0], solution.y[2]) plt.xlabel(\"x position (m)\") plt.ylabel(\"y position (m)\") plt.title(\"Payload Trajectory Near Earth\") plt.axis('equal') plt.grid(True) plt.show()","title":"Python Simulation of Trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_2/#hints-and-resources","text":"Use fundamental gravitational principles: Newton\u2019s Law of Gravitation and Kepler\u2019s Laws. Leverage numerical tools (Python) to simulate orbits and trajectories. Apply to space mission planning, satellite deployment, and planetary exploration.","title":"Hints and Resources"},{"location":"1%20Physics/2%20Gravity/Problem_2/#deliverables-summary","text":"Clean Markdown document ready for Visual Studio & GitHub. All physical explanations and mathematical derivations. Full Python code for simulation and visualization. Graphs for escape velocities and orbital trajectories.","title":"Deliverables Summary"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"This project provides a strong foundation for understanding how gravity governs motion and escape conditions in space. From satellite launches to deep space missions, the principles explored here are critical in real-world aerospace engineering.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This problem blends principles of orbital mechanics and numerical methods. Understanding these trajectories is vital for space missions, such as deploying payloads or returning objects to Earth. Task Analyze the possible trajectories (e.g., parabolic, hyperbolic, elliptical) of a payload released near Earth. Perform a numerical analysis to compute the path of the payload based on given initial conditions (position, velocity, and altitude). Discuss how these trajectories relate to orbital insertion, reentry, or escape scenarios. Develop a computational tool to simulate and visualize the motion of the payload under Earth's gravity. Hints and Resources Use fundamental gravitational principles, such as Newton's Law of Gravitation and Kepler's Laws, to derive equations and analyze scenarios. Leverage numerical methods or software tools (e.g., Python) to simulate orbits and trajectories. Explore real-world applications, such as space mission planning, satellite deployment, and planetary exploration. Implementation Orbital Mechanics The motion of an object under Earth's gravity is governed by Newton's second law: $$ F = \\frac{G M m}{r^2} $$ where: \\(G\\) is the gravitational constant, \\(M\\) is Earth's mass, \\(m\\) is the payload's mass, \\(r\\) is the distance from Earth's center. Depending on the object's velocity, different types of trajectories occur: Elliptical (Bound Orbit) : Velocity is below escape velocity. Parabolic (Escape Trajectory) : Velocity equals escape velocity. Hyperbolic (Unbound Escape) : Velocity exceeds escape velocity. Python Code Version of the Simulation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R = 6371000 # Radius of Earth (m) def equations(t, y): x, vx, y, vy = y r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, ax, vy, ay] # Initial conditions (position and velocity) x0, y0 = R + 500000, 0 # 500 km altitude vx0, vy0 = 0, 7500 # Approximate orbital velocity (m/s) y_init = [x0, vx0, y0, vy0] t_span = (0, 10000) # Time span for simulation (seconds) t_eval = np.linspace(0, 10000, 1000) sol = solve_ivp(equations, t_span, y_init, t_eval=t_eval, method='RK45') # Plot the trajectory plt.figure(figsize=(6,6)) plt.plot(sol.y[0], sol.y[2], label='Payload Trajectory') plt.scatter(0, 0, color='blue', label='Earth', s=100) plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.legend() plt.title('Simulated Payload Trajectory') plt.grid() plt.show()","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This problem blends principles of orbital mechanics and numerical methods. Understanding these trajectories is vital for space missions, such as deploying payloads or returning objects to Earth.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task","text":"Analyze the possible trajectories (e.g., parabolic, hyperbolic, elliptical) of a payload released near Earth. Perform a numerical analysis to compute the path of the payload based on given initial conditions (position, velocity, and altitude). Discuss how these trajectories relate to orbital insertion, reentry, or escape scenarios. Develop a computational tool to simulate and visualize the motion of the payload under Earth's gravity.","title":"Task"},{"location":"1%20Physics/2%20Gravity/Problem_3/#hints-and-resources","text":"Use fundamental gravitational principles, such as Newton's Law of Gravitation and Kepler's Laws, to derive equations and analyze scenarios. Leverage numerical methods or software tools (e.g., Python) to simulate orbits and trajectories. Explore real-world applications, such as space mission planning, satellite deployment, and planetary exploration.","title":"Hints and Resources"},{"location":"1%20Physics/2%20Gravity/Problem_3/#implementation","text":"","title":"Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-mechanics","text":"The motion of an object under Earth's gravity is governed by Newton's second law: $$ F = \\frac{G M m}{r^2} $$ where: \\(G\\) is the gravitational constant, \\(M\\) is Earth's mass, \\(m\\) is the payload's mass, \\(r\\) is the distance from Earth's center. Depending on the object's velocity, different types of trajectories occur: Elliptical (Bound Orbit) : Velocity is below escape velocity. Parabolic (Escape Trajectory) : Velocity equals escape velocity. Hyperbolic (Unbound Escape) : Velocity exceeds escape velocity.","title":"Orbital Mechanics"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-version-of-the-simulation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R = 6371000 # Radius of Earth (m) def equations(t, y): x, vx, y, vy = y r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, ax, vy, ay] # Initial conditions (position and velocity) x0, y0 = R + 500000, 0 # 500 km altitude vx0, vy0 = 0, 7500 # Approximate orbital velocity (m/s) y_init = [x0, vx0, y0, vy0] t_span = (0, 10000) # Time span for simulation (seconds) t_eval = np.linspace(0, 10000, 1000) sol = solve_ivp(equations, t_span, y_init, t_eval=t_eval, method='RK45') # Plot the trajectory plt.figure(figsize=(6,6)) plt.plot(sol.y[0], sol.y[2], label='Payload Trajectory') plt.scatter(0, 0, color='blue', label='Earth', s=100) plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.legend() plt.title('Simulated Payload Trajectory') plt.grid() plt.show()","title":"Python Code Version of the Simulation"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface Motivation Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be clearly observed when ripples from different points meet, forming distinctive interference patterns. These patterns can show how waves combine in different ways \u2014 sometimes reinforcing each other, other times canceling each other out. Studying these patterns helps us understand wave behavior in a simple, visual way. It also allows us to explore important concepts, like the relationship between wave phase and the effects of multiple sources. This task offers a hands-on approach to learning about wave interactions and their real-world applications, making it an interesting and engaging way to dive into wave physics. Task A circular wave on the water surface, emitted from a point source located at (x\u2080, y\u2080), can be described by the Single Disturbance equation : \u03b7(x, y, t) = A / \u221ar * cos(k * r - \u03c9 * t + \u03c6) where: \u03b7(x, y, t) is the displacement of the water surface at position (x, y) and time t A is the amplitude of the wave k = 2\u03c0 / \u03bb is the wave number (related to wavelength \u03bb) \u03c9 = 2\u03c0 * f is the angular frequency (related to frequency f) r = \u221a[(x - x\u2080)\u00b2 + (y - y\u2080)\u00b2] is the distance from the source to point (x, y) \u03c6 is the initial phase of the wave Problem Statement Your task is to analyze the interference patterns formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a chosen regular polygon. Steps to Follow Select a Regular Polygon (e.g., triangle, square, pentagon) Position the sources at the vertices of the polygon. Use the wave equation for each source. Superimpose the waves using: \u03b7_sum(x, y, t) = \u03a3 (from i=1 to N) \u03b7\u1d62(x, y, t) Analyze the interference pattern as a function of position (x, y) and time t. Visualize the constructive and destructive interference regions. Considerations All wave sources have the same amplitude A, wavelength \u03bb, and frequency f. The waves are coherent, maintaining constant phase differences. Use Python (with NumPy, Matplotlib) to simulate and visualize the wave field. Python Implementation import numpy as np import matplotlib.pyplot as plt # --- Wave Parameters --- A = 1 # Amplitude \u03bb = 1 # Wavelength f = 1 # Frequency k = 2 * np.pi / \u03bb # Wave number \u03c9 = 2 * np.pi * f # Angular frequency \u03c6 = 0 # Phase t = 0 # Time snapshot # --- Grid Setup --- x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # --- Source Setup (Regular Triangle) --- R = 2 # Radius of polygon N = 3 # Number of vertices (triangle) angles = np.linspace(0, 2 * np.pi, N, endpoint=False) sources = [(R * np.cos(\u03b8), R * np.sin(\u03b8)) for \u03b8 in angles] # --- Superposition of Waves --- \u03b7_sum = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) \u03b7 = A / np.sqrt(r + 1e-6) * np.cos(k * r - \u03c9 * t + \u03c6) \u03b7_sum += \u03b7 # --- Plot Interference Pattern --- plt.figure(figsize=(8, 6)) plt.pcolormesh(X, Y, \u03b7_sum, shading='auto', cmap='RdBu') plt.colorbar(label='Wave Displacement') plt.title('Interference Pattern from Triangle Wave Sources') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.tight_layout() plt.show() Results & Discussion Constructive Interference : Occurs where the wave crests align, resulting in amplified wave heights. Destructive Interference : Occurs where crests and troughs cancel each other out. Pattern Shape : The symmetry of the polygon is reflected in the wave pattern\u2019s geometry. This simulation demonstrates the importance of source geometry and phase relationships in wave interference phenomena. Deliverables A complete Markdown file containing the full Python simulation code. Detailed explanation of how the interference patterns arise based on wave superposition. Graphical output clearly showing interference zones (constructive and destructive regions).","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be clearly observed when ripples from different points meet, forming distinctive interference patterns. These patterns can show how waves combine in different ways \u2014 sometimes reinforcing each other, other times canceling each other out. Studying these patterns helps us understand wave behavior in a simple, visual way. It also allows us to explore important concepts, like the relationship between wave phase and the effects of multiple sources. This task offers a hands-on approach to learning about wave interactions and their real-world applications, making it an interesting and engaging way to dive into wave physics.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#task","text":"A circular wave on the water surface, emitted from a point source located at (x\u2080, y\u2080), can be described by the Single Disturbance equation : \u03b7(x, y, t) = A / \u221ar * cos(k * r - \u03c9 * t + \u03c6) where: \u03b7(x, y, t) is the displacement of the water surface at position (x, y) and time t A is the amplitude of the wave k = 2\u03c0 / \u03bb is the wave number (related to wavelength \u03bb) \u03c9 = 2\u03c0 * f is the angular frequency (related to frequency f) r = \u221a[(x - x\u2080)\u00b2 + (y - y\u2080)\u00b2] is the distance from the source to point (x, y) \u03c6 is the initial phase of the wave","title":"Task"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-statement","text":"Your task is to analyze the interference patterns formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a chosen regular polygon.","title":"Problem Statement"},{"location":"1%20Physics/3%20Waves/Problem_1/#steps-to-follow","text":"Select a Regular Polygon (e.g., triangle, square, pentagon) Position the sources at the vertices of the polygon. Use the wave equation for each source. Superimpose the waves using: \u03b7_sum(x, y, t) = \u03a3 (from i=1 to N) \u03b7\u1d62(x, y, t) Analyze the interference pattern as a function of position (x, y) and time t. Visualize the constructive and destructive interference regions.","title":"Steps to Follow"},{"location":"1%20Physics/3%20Waves/Problem_1/#considerations","text":"All wave sources have the same amplitude A, wavelength \u03bb, and frequency f. The waves are coherent, maintaining constant phase differences. Use Python (with NumPy, Matplotlib) to simulate and visualize the wave field.","title":"Considerations"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-implementation","text":"import numpy as np import matplotlib.pyplot as plt # --- Wave Parameters --- A = 1 # Amplitude \u03bb = 1 # Wavelength f = 1 # Frequency k = 2 * np.pi / \u03bb # Wave number \u03c9 = 2 * np.pi * f # Angular frequency \u03c6 = 0 # Phase t = 0 # Time snapshot # --- Grid Setup --- x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # --- Source Setup (Regular Triangle) --- R = 2 # Radius of polygon N = 3 # Number of vertices (triangle) angles = np.linspace(0, 2 * np.pi, N, endpoint=False) sources = [(R * np.cos(\u03b8), R * np.sin(\u03b8)) for \u03b8 in angles] # --- Superposition of Waves --- \u03b7_sum = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) \u03b7 = A / np.sqrt(r + 1e-6) * np.cos(k * r - \u03c9 * t + \u03c6) \u03b7_sum += \u03b7 # --- Plot Interference Pattern --- plt.figure(figsize=(8, 6)) plt.pcolormesh(X, Y, \u03b7_sum, shading='auto', cmap='RdBu') plt.colorbar(label='Wave Displacement') plt.title('Interference Pattern from Triangle Wave Sources') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.tight_layout() plt.show()","title":"Python Implementation"},{"location":"1%20Physics/3%20Waves/Problem_1/#results-discussion","text":"Constructive Interference : Occurs where the wave crests align, resulting in amplified wave heights. Destructive Interference : Occurs where crests and troughs cancel each other out. Pattern Shape : The symmetry of the polygon is reflected in the wave pattern\u2019s geometry. This simulation demonstrates the importance of source geometry and phase relationships in wave interference phenomena.","title":"Results &amp; Discussion"},{"location":"1%20Physics/3%20Waves/Problem_1/#deliverables","text":"A complete Markdown file containing the full Python simulation code. Detailed explanation of how the interference patterns arise based on wave superposition. Graphical output clearly showing interference zones (constructive and destructive regions).","title":"Deliverables"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Simulating the Effects of the Lorentz Force Motivation The Lorentz force is fundamental in understanding how charged particles move under electric and magnetic fields. It plays a crucial role in many areas of physics including plasma physics, particle accelerators, and astrophysics. By simulating the Lorentz force, we gain insights into particle trajectories and can visualize phenomena such as circular motion, drift velocity, and helical paths, which are essential in practical devices like cyclotrons and mass spectrometers. The Lorentz force is mathematically expressed as \\[ \\mathbf{F} = q \\mathbf{E} + q \\mathbf{v} \\times \\mathbf{B}, \\] where \\(q\\) is the particle charge, \\(\\mathbf{E}\\) is the electric field vector, \\(\\mathbf{v}\\) is the particle velocity vector, and \\(\\mathbf{B}\\) is the magnetic field vector. Task 1. Exploration of Applications Identify systems where the Lorentz force is crucial (e.g., particle accelerators, mass spectrometers, plasma confinement). Discuss how electric \\(\\mathbf{E}\\) and magnetic \\(\\mathbf{B}\\) fields influence charged particle trajectories. 2. Simulating Particle Motion Implement simulations to compute and visualize trajectories of a charged particle under: Uniform magnetic field. Combined uniform electric and magnetic fields. Crossed electric and magnetic fields. Simulate circular, helical, or drift motions based on initial velocities and fields. 3. Parameter Exploration Allow variations in: Field strengths \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) . Initial velocity \\(\\mathbf{v}\\) . Charge \\(q\\) and mass \\(m\\) . Analyze the effects of these parameters on the particle\u2019s trajectory. 4. Visualization Generate clear 2D and 3D plots with proper labels. Highlight key physical features such as Larmor radius and drift velocity. Deliverables Markdown document containing the explanation and Python simulation code. Visualizations of particle trajectories for different field configurations. Discussion relating simulation results to practical applications. Suggestions for extending the simulation to more complex scenarios (e.g., non-uniform fields). Hints and Resources Use numerical methods such as Euler integration to solve the equations of motion. Utilize Python libraries like NumPy and Matplotlib for computation and visualization. Begin with simple cases and gradually introduce complexity. Python Code Implementation import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants (normalized units) q = 1.0 # Charge (arbitrary units) m = 1.0 # Mass (arbitrary units) # Time parameters dt = 0.01 # Time step (seconds) steps = 1000 # Number of simulation steps # Lorentz force calculation def lorentz_force(q, E, v, B): return q * (E + np.cross(v, B)) # Euler method simulation of particle motion def simulate_motion(q, m, E, B, v0, dt, steps): positions = np.zeros((steps, 3)) velocities = np.zeros((steps, 3)) velocities[0] = v0 for i in range(1, steps): F = lorentz_force(q, E, velocities[i-1], B) a = F / m velocities[i] = velocities[i-1] + a * dt positions[i] = positions[i-1] + velocities[i] * dt return positions, velocities # Plotting trajectories def plot_trajectory(positions, title, is_3d=False): if is_3d: fig = plt.figure(figsize=(8,6)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:,0], positions[:,1], positions[:,2]) ax.set_xlabel('X Position') ax.set_ylabel('Y Position') ax.set_zlabel('Z Position') ax.set_title(title) else: plt.figure(figsize=(8,6)) plt.plot(positions[:,0], positions[:,1]) plt.xlabel('X Position') plt.ylabel('Y Position') plt.title(title) plt.grid(True) plt.show() # Initial velocity for simulations initial_velocity = np.array([1.0, 0.0, 0.0]) # 1) Uniform magnetic field only (circular motion) E_field = np.array([0.0, 0.0, 0.0]) B_field = np.array([0.0, 0.0, 1.0]) pos, vel = simulate_motion(q, m, E_field, B_field, initial_velocity, dt, steps) plot_trajectory(pos, \"Uniform Magnetic Field - 2D Trajectory\") # 2) Combined uniform electric and magnetic fields E_field = np.array([0.0, 1.0, 0.0]) B_field = np.array([0.0, 0.0, 1.0]) pos, vel = simulate_motion(q, m, E_field, B_field, initial_velocity, dt, steps) plot_trajectory(pos, \"Combined Electric and Magnetic Fields - 2D Trajectory\") # 3) Crossed electric and magnetic fields E_field = np.array([1.0, 0.0, 0.0]) B_field = np.array([0.0, 0.0, 1.0]) pos, vel = simulate_motion(q, m, E_field, B_field, initial_velocity, dt, steps) plot_trajectory(pos, \"Crossed Electric and Magnetic Fields - 2D Trajectory\") # 4) Helical motion in uniform magnetic field (3D) initial_velocity = np.array([1.0, 1.0, 0.0]) E_field = np.array([0.0, 0.0, 0.0]) B_field = np.array([0.0, 0.0, 1.0]) pos, vel = simulate_motion(q, m, E_field, B_field, initial_velocity, dt, steps) plot_trajectory(pos, \"Helical Motion in Uniform Magnetic Field - 3D Trajectory\", is_3d=True)","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force is fundamental in understanding how charged particles move under electric and magnetic fields. It plays a crucial role in many areas of physics including plasma physics, particle accelerators, and astrophysics. By simulating the Lorentz force, we gain insights into particle trajectories and can visualize phenomena such as circular motion, drift velocity, and helical paths, which are essential in practical devices like cyclotrons and mass spectrometers. The Lorentz force is mathematically expressed as \\[ \\mathbf{F} = q \\mathbf{E} + q \\mathbf{v} \\times \\mathbf{B}, \\] where \\(q\\) is the particle charge, \\(\\mathbf{E}\\) is the electric field vector, \\(\\mathbf{v}\\) is the particle velocity vector, and \\(\\mathbf{B}\\) is the magnetic field vector.","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#task","text":"","title":"Task"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-exploration-of-applications","text":"Identify systems where the Lorentz force is crucial (e.g., particle accelerators, mass spectrometers, plasma confinement). Discuss how electric \\(\\mathbf{E}\\) and magnetic \\(\\mathbf{B}\\) fields influence charged particle trajectories.","title":"1. Exploration of Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulating-particle-motion","text":"Implement simulations to compute and visualize trajectories of a charged particle under: Uniform magnetic field. Combined uniform electric and magnetic fields. Crossed electric and magnetic fields. Simulate circular, helical, or drift motions based on initial velocities and fields.","title":"2. Simulating Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-parameter-exploration","text":"Allow variations in: Field strengths \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) . Initial velocity \\(\\mathbf{v}\\) . Charge \\(q\\) and mass \\(m\\) . Analyze the effects of these parameters on the particle\u2019s trajectory.","title":"3. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-visualization","text":"Generate clear 2D and 3D plots with proper labels. Highlight key physical features such as Larmor radius and drift velocity.","title":"4. Visualization"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#deliverables","text":"Markdown document containing the explanation and Python simulation code. Visualizations of particle trajectories for different field configurations. Discussion relating simulation results to practical applications. Suggestions for extending the simulation to more complex scenarios (e.g., non-uniform fields).","title":"Deliverables"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#hints-and-resources","text":"Use numerical methods such as Euler integration to solve the equations of motion. Utilize Python libraries like NumPy and Matplotlib for computation and visualization. Begin with simple cases and gradually introduce complexity.","title":"Hints and Resources"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-code-implementation","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants (normalized units) q = 1.0 # Charge (arbitrary units) m = 1.0 # Mass (arbitrary units) # Time parameters dt = 0.01 # Time step (seconds) steps = 1000 # Number of simulation steps # Lorentz force calculation def lorentz_force(q, E, v, B): return q * (E + np.cross(v, B)) # Euler method simulation of particle motion def simulate_motion(q, m, E, B, v0, dt, steps): positions = np.zeros((steps, 3)) velocities = np.zeros((steps, 3)) velocities[0] = v0 for i in range(1, steps): F = lorentz_force(q, E, velocities[i-1], B) a = F / m velocities[i] = velocities[i-1] + a * dt positions[i] = positions[i-1] + velocities[i] * dt return positions, velocities # Plotting trajectories def plot_trajectory(positions, title, is_3d=False): if is_3d: fig = plt.figure(figsize=(8,6)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:,0], positions[:,1], positions[:,2]) ax.set_xlabel('X Position') ax.set_ylabel('Y Position') ax.set_zlabel('Z Position') ax.set_title(title) else: plt.figure(figsize=(8,6)) plt.plot(positions[:,0], positions[:,1]) plt.xlabel('X Position') plt.ylabel('Y Position') plt.title(title) plt.grid(True) plt.show() # Initial velocity for simulations initial_velocity = np.array([1.0, 0.0, 0.0]) # 1) Uniform magnetic field only (circular motion) E_field = np.array([0.0, 0.0, 0.0]) B_field = np.array([0.0, 0.0, 1.0]) pos, vel = simulate_motion(q, m, E_field, B_field, initial_velocity, dt, steps) plot_trajectory(pos, \"Uniform Magnetic Field - 2D Trajectory\") # 2) Combined uniform electric and magnetic fields E_field = np.array([0.0, 1.0, 0.0]) B_field = np.array([0.0, 0.0, 1.0]) pos, vel = simulate_motion(q, m, E_field, B_field, initial_velocity, dt, steps) plot_trajectory(pos, \"Combined Electric and Magnetic Fields - 2D Trajectory\") # 3) Crossed electric and magnetic fields E_field = np.array([1.0, 0.0, 0.0]) B_field = np.array([0.0, 0.0, 1.0]) pos, vel = simulate_motion(q, m, E_field, B_field, initial_velocity, dt, steps) plot_trajectory(pos, \"Crossed Electric and Magnetic Fields - 2D Trajectory\") # 4) Helical motion in uniform magnetic field (3D) initial_velocity = np.array([1.0, 1.0, 0.0]) E_field = np.array([0.0, 0.0, 0.0]) B_field = np.array([0.0, 0.0, 1.0]) pos, vel = simulate_motion(q, m, E_field, B_field, initial_velocity, dt, steps) plot_trajectory(pos, \"Helical Motion in Uniform Magnetic Field - 3D Trajectory\", is_3d=True)","title":"Python Code Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Using Graph Theory Motivation: Calculating equivalent resistance is a fundamental problem in electrical circuits, essential for understanding and designing efficient systems. While traditional methods involve iteratively applying series and parallel resistor rules, these approaches can become cumbersome for complex circuits with many components. Graph theory offers a powerful alternative, providing a structured and algorithmic way to analyze circuits. By representing a circuit as a graph () where nodes correspond to junctions and edges represent resistors with weights equal to their resistance values () we can systematically simplify even the most intricate networks. This method not only streamlines calculations but also opens the door to automated analysis, making it particularly useful in modern applications like circuit simulation software, optimization problems, and network design. Studying equivalent resistance through graph theory is valuable not only for its practical applications but also for the deeper insights it provides into the interplay between electrical and mathematical concepts. This approach highlights the versatility of graph theory, demonstrating its relevance across physics, engineering, and computer science. Task Option: Advanced Task \u2013 Full Implementation Step 1: Python Implementation Using NetworkX import networkx as nx def combine_series(G): changed = True while changed: changed = False for node in list(G.nodes()): if G.degree(node) == 2: neighbors = list(G.neighbors(node)) if neighbors[0] != neighbors[1] and G.has_edge(neighbors[0], neighbors[1]) is False: r1 = G[node][neighbors[0]]['resistance'] r2 = G[node][neighbors[1]]['resistance'] total_r = r1 + r2 # Equivalent: R = R_1 + R_2 G.add_edge(neighbors[0], neighbors[1], resistance=total_r) G.remove_node(node) changed = True break return G def combine_parallel(G): checked_pairs = set() for u, v in list(G.edges()): if (u, v) in checked_pairs or (v, u) in checked_pairs: continue parallels = [key for key in G[u][v] if 'resistance' in G[u][v][key]] if isinstance(G[u][v], dict) else [G[u][v]] total_inv_r = 0 parallel_edges = [(u, v)] for edge in parallel_edges: total_inv_r += 1 / G[edge[0]][edge[1]]['resistance'] # 1/R_eq = 1/R1 + 1/R2 + ... if total_inv_r != 0: G.remove_edge(u, v) G.add_edge(u, v, resistance=1 / total_inv_r) checked_pairs.add((u, v)) return G def simplify_graph(G): prev_edges = -1 while prev_edges != len(G.edges): prev_edges = len(G.edges) G = combine_series(G) G = combine_parallel(G) return G def calculate_equivalent_resistance(G, start, end): G = simplify_graph(G) if G.has_edge(start, end): return G[start][end]['resistance'] else: return float('inf') Step 2: Test the Implementation # Example 1: Simple Series G1 = nx.Graph() G1.add_edge('A', 'B', resistance=2) G1.add_edge('B', 'C', resistance=3) result1 = calculate_equivalent_resistance(G1, 'A', 'C') print(f\"Test 1 - Series: {result1} Ohms\") # Example 2: Simple Parallel G2 = nx.Graph() G2.add_edge('A', 'B', resistance=2) G2.add_edge('A', 'B', resistance=2) result2 = calculate_equivalent_resistance(G2, 'A', 'B') print(f\"Test 2 - Parallel: {result2} Ohms\") # Example 3: Complex with cycle G3 = nx.Graph() G3.add_edge('A', 'B', resistance=1) G3.add_edge('B', 'C', resistance=1) G3.add_edge('C', 'A', resistance=1) result3 = calculate_equivalent_resistance(G3, 'A', 'C') print(f\"Test 3 - Triangle Cycle: {result3:.2f} Ohms\") Deliverables: A full implementation of the algorithm in Python using NetworkX. Handles complex circuit configurations on three example inputs. Includes simplification logic for both series and parallel connections. Efficiency and Improvements Current implementation uses simple iterative reduction. Efficiency can be improved by adding memoization and more robust cycle detection. DFS or Union-Find structures can further optimize nested detection patterns. Hints and Resources Use networkx for graph creation and manipulation. Use depth-first search (DFS) to identify paths and cycles. Start with isolated series reductions before attempting parallel simplifications. Ensure unit testing with multiple input scenarios.","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"Calculating equivalent resistance is a fundamental problem in electrical circuits, essential for understanding and designing efficient systems. While traditional methods involve iteratively applying series and parallel resistor rules, these approaches can become cumbersome for complex circuits with many components. Graph theory offers a powerful alternative, providing a structured and algorithmic way to analyze circuits. By representing a circuit as a graph () where nodes correspond to junctions and edges represent resistors with weights equal to their resistance values () we can systematically simplify even the most intricate networks. This method not only streamlines calculations but also opens the door to automated analysis, making it particularly useful in modern applications like circuit simulation software, optimization problems, and network design. Studying equivalent resistance through graph theory is valuable not only for its practical applications but also for the deeper insights it provides into the interplay between electrical and mathematical concepts. This approach highlights the versatility of graph theory, demonstrating its relevance across physics, engineering, and computer science.","title":"Motivation:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#task-option-advanced-task-full-implementation","text":"","title":"Task Option: Advanced Task \u2013 Full Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-1-python-implementation-using-networkx","text":"import networkx as nx def combine_series(G): changed = True while changed: changed = False for node in list(G.nodes()): if G.degree(node) == 2: neighbors = list(G.neighbors(node)) if neighbors[0] != neighbors[1] and G.has_edge(neighbors[0], neighbors[1]) is False: r1 = G[node][neighbors[0]]['resistance'] r2 = G[node][neighbors[1]]['resistance'] total_r = r1 + r2 # Equivalent: R = R_1 + R_2 G.add_edge(neighbors[0], neighbors[1], resistance=total_r) G.remove_node(node) changed = True break return G def combine_parallel(G): checked_pairs = set() for u, v in list(G.edges()): if (u, v) in checked_pairs or (v, u) in checked_pairs: continue parallels = [key for key in G[u][v] if 'resistance' in G[u][v][key]] if isinstance(G[u][v], dict) else [G[u][v]] total_inv_r = 0 parallel_edges = [(u, v)] for edge in parallel_edges: total_inv_r += 1 / G[edge[0]][edge[1]]['resistance'] # 1/R_eq = 1/R1 + 1/R2 + ... if total_inv_r != 0: G.remove_edge(u, v) G.add_edge(u, v, resistance=1 / total_inv_r) checked_pairs.add((u, v)) return G def simplify_graph(G): prev_edges = -1 while prev_edges != len(G.edges): prev_edges = len(G.edges) G = combine_series(G) G = combine_parallel(G) return G def calculate_equivalent_resistance(G, start, end): G = simplify_graph(G) if G.has_edge(start, end): return G[start][end]['resistance'] else: return float('inf')","title":"Step 1: Python Implementation Using NetworkX"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-2-test-the-implementation","text":"# Example 1: Simple Series G1 = nx.Graph() G1.add_edge('A', 'B', resistance=2) G1.add_edge('B', 'C', resistance=3) result1 = calculate_equivalent_resistance(G1, 'A', 'C') print(f\"Test 1 - Series: {result1} Ohms\") # Example 2: Simple Parallel G2 = nx.Graph() G2.add_edge('A', 'B', resistance=2) G2.add_edge('A', 'B', resistance=2) result2 = calculate_equivalent_resistance(G2, 'A', 'B') print(f\"Test 2 - Parallel: {result2} Ohms\") # Example 3: Complex with cycle G3 = nx.Graph() G3.add_edge('A', 'B', resistance=1) G3.add_edge('B', 'C', resistance=1) G3.add_edge('C', 'A', resistance=1) result3 = calculate_equivalent_resistance(G3, 'A', 'C') print(f\"Test 3 - Triangle Cycle: {result3:.2f} Ohms\")","title":"Step 2: Test the Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#deliverables","text":"A full implementation of the algorithm in Python using NetworkX. Handles complex circuit configurations on three example inputs. Includes simplification logic for both series and parallel connections.","title":"Deliverables:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#efficiency-and-improvements","text":"Current implementation uses simple iterative reduction. Efficiency can be improved by adding memoization and more robust cycle detection. DFS or Union-Find structures can further optimize nested detection patterns.","title":"Efficiency and Improvements"},{"location":"1%20Physics/5%20Circuits/Problem_1/#hints-and-resources","text":"Use networkx for graph creation and manipulation. Use depth-first search (DFS) to identify paths and cycles. Start with isolated series reductions before attempting parallel simplifications. Ensure unit testing with multiple input scenarios.","title":"Hints and Resources"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Exploring the Central Limit Theorem through Simulations Motivation The Central Limit Theorem (CLT) is a fundamental concept in probability and statistics. It states that the sampling distribution of the sample mean becomes approximately normal as the sample size increases , regardless of the shape of the population distribution. Formally, if we take samples of size \\( n \\) from a population with mean \\( \\mu \\) and variance \\( \\sigma^2 \\) , the distribution of the sample means \\( \\bar{X} \\) tends toward a normal distribution: \\[ \\bar{X} \\sim \\mathcal{N}(\\mu, \\frac{\\sigma^2}{n}) \\] This powerful result allows us to make inferences about populations using the normal distribution\u2014even if the original population is not normal. Task 1. Simulating Sampling Distributions Use different population distributions: Uniform distribution Exponential distribution Binomial distribution Create a large population dataset for each. 2. Sampling and Visualization Randomly draw samples and compute their means for sample sizes like \\( n = 5, 10, 30, 50 \\) . Repeat sampling multiple times to generate the sampling distribution . Visualize histograms of sample means and check their convergence to normality . 3. Parameter Exploration Explore how the original distribution shape and sample size affect the convergence rate. Analyze how population variance \\( \\sigma^2 \\) influences the spread of the sampling distribution (i.e., \\( \\frac{\\sigma^2}{n} \\) ). 4. Practical Applications Estimate unknown population parameters \\( \\mu \\) . Monitor product quality in manufacturing. Make predictions in financial models using expected values. Deliverables Python scripts or notebooks implementing the simulations. Plots showing the evolution of sampling distributions toward normality. A discussion linking results to theoretical CLT expectations. Hints and Resources Use NumPy for number generation and Seaborn / Matplotlib for plots. Start with simple distributions like uniform. Emphasize the meaning of sample mean \\( \\bar{X} \\) and sample variance. Python Code # clt_simulation.py # Central Limit Theorem Simulation # Author: [Your Name] import numpy as np import matplotlib.pyplot as plt import seaborn as sns sns.set(style=\"whitegrid\") sample_sizes = [5, 10, 30, 50] population_size = 100000 num_samples = 1000 def generate_population(distribution, size): if distribution == \"uniform\": return np.random.uniform(0, 100, size) elif distribution == \"exponential\": return np.random.exponential(scale=10, size=size) elif distribution == \"binomial\": return np.random.binomial(n=20, p=0.5, size=size) else: raise ValueError(\"Unsupported distribution.\") def simulate_sampling(population, sample_sizes, num_samples): results = {} for size in sample_sizes: means = [] for _ in range(num_samples): sample = np.random.choice(population, size=size, replace=False) means.append(np.mean(sample)) results[size] = means return results def plot_sampling_distributions(results, distribution_name): fig, axes = plt.subplots(2, 2, figsize=(12, 8)) axes = axes.flatten() for idx, size in enumerate(results): sns.histplot(results[size], kde=True, ax=axes[idx], color=\"skyblue\", stat=\"density\") axes[idx].set_title(f\"{distribution_name.capitalize()} - Sample Size {size}\") axes[idx].set_xlabel(\"Sample Mean\") axes[idx].set_ylabel(\"Density\") plt.tight_layout() plt.show() def run_simulation(): distributions = [\"uniform\", \"exponential\", \"binomial\"] for dist in distributions: print(f\"\\n\ud83d\udd0d Simulating {dist.capitalize()} Distribution...\") population = generate_population(dist, population_size) results = simulate_sampling(population, sample_sizes, num_samples) plot_sampling_distributions(results, dist) if __name__ == \"__main__\": run_simulation() Results & Discussion Observation of Sampling Distributions After simulating samples from different distributions (Uniform, Exponential, Binomial), we observe the following: Uniform Distribution : Converges to a normal distribution very quickly, even with small sample sizes like \\( n = 10 \\) . Exponential Distribution : Skewed heavily at the start, but the distribution of sample means becomes noticeably symmetric as \\( n \\) increases to 30 and 50. Binomial Distribution : With parameters \\( n = 20 \\) , \\( p = 0.5 \\) , already fairly symmetric, so convergence is very fast. This directly demonstrates the Central Limit Theorem in action. As sample size increases, the distribution of the sample mean becomes more bell-shaped and centered around the population mean \\( \\mu \\) , regardless of the population\u2019s original shape. Theoretical Validation According to the CLT, for large \\( n \\) , the sampling distribution of the sample mean \\( \\bar{X} \\) will be approximately: \\[ \\bar{X} \\sim \\mathcal{N}(\\mu, \\frac{\\sigma^2}{n}) \\] Our simulation confirms this: The mean of the sample means is close to \\( \\mu \\) The spread of the sample means decreases with increasing \\( n \\) , matching the formula \\( \\frac{\\sigma^2}{n} \\) The histograms show clear convergence toward a normal shape Practical Applications of the Central Limit Theorem 1. Estimating Population Parameters In practice, we often use sample means to estimate unknown population means \\( \\mu \\) . CLT justifies this by ensuring that with a sufficiently large sample size, we can assume normality in the sampling distribution, making confidence intervals and hypothesis tests valid. 2. Quality Control in Manufacturing In industrial settings, averages of product measurements (e.g., lengths, weights) are used to monitor production. Thanks to CLT, these averages can be treated as normally distributed, which simplifies control charts and decision making. 3. Financial Modeling and Risk Management Financial analysts often rely on expected returns from portfolios. Even if daily returns are not normally distributed, their averages over long periods tend to be normally distributed due to the CLT. This is critical in options pricing, risk forecasts, and economic modeling. Conclusion The Central Limit Theorem is not just a theoretical concept \u2014 it has real power in data science, industry, and finance. Through this project, we've visually and numerically validated how it operates and why it\u2019s such a cornerstone of statistical inference. This assignment helped solidify understanding by: Simulating from various distributions Observing convergence of sampling distributions Exploring how sample size and distribution shape influence results Applying statistical reasoning to real-world scenarios","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exploring-the-central-limit-theorem-through-simulations","text":"","title":"Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is a fundamental concept in probability and statistics. It states that the sampling distribution of the sample mean becomes approximately normal as the sample size increases , regardless of the shape of the population distribution. Formally, if we take samples of size \\( n \\) from a population with mean \\( \\mu \\) and variance \\( \\sigma^2 \\) , the distribution of the sample means \\( \\bar{X} \\) tends toward a normal distribution: \\[ \\bar{X} \\sim \\mathcal{N}(\\mu, \\frac{\\sigma^2}{n}) \\] This powerful result allows us to make inferences about populations using the normal distribution\u2014even if the original population is not normal.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task","text":"","title":"Task"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-simulating-sampling-distributions","text":"Use different population distributions: Uniform distribution Exponential distribution Binomial distribution Create a large population dataset for each.","title":"1. Simulating Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-sampling-and-visualization","text":"Randomly draw samples and compute their means for sample sizes like \\( n = 5, 10, 30, 50 \\) . Repeat sampling multiple times to generate the sampling distribution . Visualize histograms of sample means and check their convergence to normality .","title":"2. Sampling and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-parameter-exploration","text":"Explore how the original distribution shape and sample size affect the convergence rate. Analyze how population variance \\( \\sigma^2 \\) influences the spread of the sampling distribution (i.e., \\( \\frac{\\sigma^2}{n} \\) ).","title":"3. Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-practical-applications","text":"Estimate unknown population parameters \\( \\mu \\) . Monitor product quality in manufacturing. Make predictions in financial models using expected values.","title":"4. Practical Applications"},{"location":"1%20Physics/6%20Statistics/Problem_1/#deliverables","text":"Python scripts or notebooks implementing the simulations. Plots showing the evolution of sampling distributions toward normality. A discussion linking results to theoretical CLT expectations.","title":"Deliverables"},{"location":"1%20Physics/6%20Statistics/Problem_1/#hints-and-resources","text":"Use NumPy for number generation and Seaborn / Matplotlib for plots. Start with simple distributions like uniform. Emphasize the meaning of sample mean \\( \\bar{X} \\) and sample variance.","title":"Hints and Resources"},{"location":"1%20Physics/6%20Statistics/Problem_1/#python-code","text":"# clt_simulation.py # Central Limit Theorem Simulation # Author: [Your Name] import numpy as np import matplotlib.pyplot as plt import seaborn as sns sns.set(style=\"whitegrid\") sample_sizes = [5, 10, 30, 50] population_size = 100000 num_samples = 1000 def generate_population(distribution, size): if distribution == \"uniform\": return np.random.uniform(0, 100, size) elif distribution == \"exponential\": return np.random.exponential(scale=10, size=size) elif distribution == \"binomial\": return np.random.binomial(n=20, p=0.5, size=size) else: raise ValueError(\"Unsupported distribution.\") def simulate_sampling(population, sample_sizes, num_samples): results = {} for size in sample_sizes: means = [] for _ in range(num_samples): sample = np.random.choice(population, size=size, replace=False) means.append(np.mean(sample)) results[size] = means return results def plot_sampling_distributions(results, distribution_name): fig, axes = plt.subplots(2, 2, figsize=(12, 8)) axes = axes.flatten() for idx, size in enumerate(results): sns.histplot(results[size], kde=True, ax=axes[idx], color=\"skyblue\", stat=\"density\") axes[idx].set_title(f\"{distribution_name.capitalize()} - Sample Size {size}\") axes[idx].set_xlabel(\"Sample Mean\") axes[idx].set_ylabel(\"Density\") plt.tight_layout() plt.show() def run_simulation(): distributions = [\"uniform\", \"exponential\", \"binomial\"] for dist in distributions: print(f\"\\n\ud83d\udd0d Simulating {dist.capitalize()} Distribution...\") population = generate_population(dist, population_size) results = simulate_sampling(population, sample_sizes, num_samples) plot_sampling_distributions(results, dist) if __name__ == \"__main__\": run_simulation()","title":"Python Code"},{"location":"1%20Physics/6%20Statistics/Problem_1/#results-discussion","text":"","title":"Results &amp; Discussion"},{"location":"1%20Physics/6%20Statistics/Problem_1/#observation-of-sampling-distributions","text":"After simulating samples from different distributions (Uniform, Exponential, Binomial), we observe the following: Uniform Distribution : Converges to a normal distribution very quickly, even with small sample sizes like \\( n = 10 \\) . Exponential Distribution : Skewed heavily at the start, but the distribution of sample means becomes noticeably symmetric as \\( n \\) increases to 30 and 50. Binomial Distribution : With parameters \\( n = 20 \\) , \\( p = 0.5 \\) , already fairly symmetric, so convergence is very fast. This directly demonstrates the Central Limit Theorem in action. As sample size increases, the distribution of the sample mean becomes more bell-shaped and centered around the population mean \\( \\mu \\) , regardless of the population\u2019s original shape.","title":"Observation of Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#theoretical-validation","text":"According to the CLT, for large \\( n \\) , the sampling distribution of the sample mean \\( \\bar{X} \\) will be approximately: \\[ \\bar{X} \\sim \\mathcal{N}(\\mu, \\frac{\\sigma^2}{n}) \\] Our simulation confirms this: The mean of the sample means is close to \\( \\mu \\) The spread of the sample means decreases with increasing \\( n \\) , matching the formula \\( \\frac{\\sigma^2}{n} \\) The histograms show clear convergence toward a normal shape","title":"Theoretical Validation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#practical-applications-of-the-central-limit-theorem","text":"","title":"Practical Applications of the Central Limit Theorem"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-estimating-population-parameters","text":"In practice, we often use sample means to estimate unknown population means \\( \\mu \\) . CLT justifies this by ensuring that with a sufficiently large sample size, we can assume normality in the sampling distribution, making confidence intervals and hypothesis tests valid.","title":"1. Estimating Population Parameters"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-quality-control-in-manufacturing","text":"In industrial settings, averages of product measurements (e.g., lengths, weights) are used to monitor production. Thanks to CLT, these averages can be treated as normally distributed, which simplifies control charts and decision making.","title":"2. Quality Control in Manufacturing"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-financial-modeling-and-risk-management","text":"Financial analysts often rely on expected returns from portfolios. Even if daily returns are not normally distributed, their averages over long periods tend to be normally distributed due to the CLT. This is critical in options pricing, risk forecasts, and economic modeling.","title":"3. Financial Modeling and Risk Management"},{"location":"1%20Physics/6%20Statistics/Problem_1/#conclusion","text":"The Central Limit Theorem is not just a theoretical concept \u2014 it has real power in data science, industry, and finance. Through this project, we've visually and numerically validated how it operates and why it\u2019s such a cornerstone of statistical inference. This assignment helped solidify understanding by: Simulating from various distributions Observing convergence of sampling distributions Exploring how sample size and distribution shape influence results Applying statistical reasoning to real-world scenarios","title":"Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 Estimating Pi using Monte Carlo Methods Motivation Monte Carlo simulations are a powerful class of computational techniques that use randomness to solve problems or estimate values. One of the most elegant applications of Monte Carlo methods is estimating the value of \\(\\pi\\) through geometric probability. By randomly generating points and analyzing their positions relative to a geometric shape, we can approximate \\(\\pi\\) in an intuitive and visually engaging way. This problem connects fundamental concepts of probability, geometry, and numerical computation. It also provides a gateway to understanding how randomness can be harnessed to solve complex problems in physics, finance, and computer science. The Monte Carlo approach to \\(\\pi\\) estimation highlights the versatility and simplicity of this method while offering practical insights into convergence rates and computational efficiency. Part 1: Estimating \\(\\pi\\) using a Circle 1. Theoretical Foundation Explain how the ratio of points inside a circle to the total number of points in a square can be used to estimate \\(\\pi\\) . Derive the formula \\[ \\pi \\approx 4 \\times \\frac{\\text{points inside the circle}}{\\text{total points}} \\] for a unit circle. 2. Simulation Generate random points in a 2D square bounding a unit circle. Count the number of points falling inside the circle. Estimate \\(\\pi\\) based on the ratio of points inside the circle to the total points. 3. Visualization Create a plot showing the randomly generated points, distinguishing those inside and outside the circle. 4. Analysis Investigate how the accuracy of the estimate improves as the number of points increases. Discuss the convergence rate and computational considerations for this method. Part 2: Estimating \\(\\pi\\) using Buffon's Needle 1. Theoretical Foundation Describe Buffon's Needle problem, where \\(\\pi\\) can be estimated based on the probability of a needle crossing parallel lines on a plane. Derive the formula: \\[ \\pi \\approx \\frac{2 \\times \\text{needle length} \\times \\text{number of throws}}{\\text{distance between lines} \\times \\text{number of crossings}} \\] 2. Simulation Simulate the random dropping of a needle on a plane with parallel lines. Count the number of times the needle crosses a line. Estimate \\(\\pi\\) based on the derived formula. 3. Visualization Create a graphical representation of the simulation, showing the needle positions relative to the lines. 4. Analysis Explore how the number of needle drops affects the estimate's accuracy. Compare the convergence rate of this method to the circle-based approach. Deliverables A Markdown document with: Clear explanations of the methods and formulas. A discussion of theoretical foundations and results. Python scripts or notebooks implementing the simulations, including: Code for the circle-based Monte Carlo method. Code for Buffon's Needle method. Graphical outputs: Plots showing random points for the circle-based method. Visualizations of needle positions for Buffon's Needle. Analysis: Tables or graphs showing the convergence of estimated \\(\\pi\\) as a function of the number of iterations for both methods. A comparison of the methods in terms of accuracy and computational efficiency. Hints and Resources Use Python libraries such as NumPy for random number generation and Matplotlib for visualizations. For the circle-based method, ensure the random points are uniformly distributed within the square. For Buffon's Needle, pay attention to geometric constraints, such as the relationship between the needle length and the distance between lines. Start with a small number of iterations to validate the implementation, then increase the sample size to observe convergence. Python Code import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(num_points): \"\"\" Estimate pi using the Monte Carlo method with random points inside a square. Points inside the unit circle are counted to estimate pi. Args: num_points (int): Number of random points to generate. Returns: pi_estimate (float): Estimated value of pi. points (ndarray): Generated points (num_points x 2). inside_mask (ndarray): Boolean mask for points inside the circle. \"\"\" # Generate random points in the square [-1, 1] x [-1, 1] points = np.random.uniform(low=-1, high=1, size=(num_points, 2)) # Calculate distances from origin (0,0) distances = np.linalg.norm(points, axis=1) # Mask for points inside the unit circle (distance <= 1) inside_mask = distances <= 1 # Estimate pi using ratio of points inside circle pi_estimate = 4 * np.sum(inside_mask) / num_points return pi_estimate, points, inside_mask def plot_circle_simulation(points, inside_mask): \"\"\" Plot the points generated for circle-based Monte Carlo simulation. Args: points (ndarray): Array of points (num_points x 2). inside_mask (ndarray): Boolean mask for points inside the circle. \"\"\" plt.figure(figsize=(6,6)) plt.scatter(points[inside_mask, 0], points[inside_mask, 1], color='blue', s=5, label='Inside Circle') plt.scatter(points[~inside_mask, 0], points[~inside_mask, 1], color='red', s=5, label='Outside Circle') circle = plt.Circle((0, 0), 1, color='black', fill=False, linewidth=1) plt.gca().add_artist(circle) plt.title('Monte Carlo Estimation of Pi - Circle Method') plt.xlabel('X') plt.ylabel('Y') plt.legend() plt.axis('square') plt.show() def estimate_pi_buffon(num_throws, needle_length=1, line_distance=1): \"\"\" Estimate pi using Buffon's Needle experiment. Args: num_throws (int): Number of needle drops. needle_length (float): Length of the needle. line_distance (float): Distance between parallel lines. Returns: pi_estimate (float): Estimated value of pi. crosses (int): Number of times needle crosses a line. needles (list of tuples): List of needle positions for visualization. Each needle is ((x_center, y_center), angle) \"\"\" crosses = 0 needles = [] for _ in range(num_throws): # Random position of needle center between 0 and line_distance / 2 center_y = np.random.uniform(0, line_distance / 2) # Random angle of needle with respect to the lines [0, pi/2] angle = np.random.uniform(0, np.pi / 2) # Calculate vertical projection of half needle length half_proj = (needle_length / 2) * np.sin(angle) # Check if needle crosses a line if center_y <= half_proj: crosses += 1 needles.append(((0, center_y), angle)) if crosses == 0: # Avoid division by zero pi_estimate = np.nan else: pi_estimate = (2 * needle_length * num_throws) / (line_distance * crosses) return pi_estimate, crosses, needles def plot_buffon_needles(needles, needle_length=1, line_distance=1, num_lines=5): \"\"\" Visualize Buffon's Needle simulation. Args: needles (list): List of needle positions ((x_center, y_center), angle). needle_length (float): Length of needles. line_distance (float): Distance between parallel lines. num_lines (int): Number of parallel lines to draw. \"\"\" plt.figure(figsize=(8, 6)) # Draw parallel lines for i in range(num_lines): y = i * line_distance plt.axhline(y=y, color='black', linewidth=1) # Plot needles for (x_center, y_center), angle in needles: x_start = x_center - (needle_length / 2) * np.cos(angle) x_end = x_center + (needle_length / 2) * np.cos(angle) y_start = y_center - (needle_length / 2) * np.sin(angle) y_end = y_center + (needle_length / 2) * np.sin(angle) plt.plot([x_start, x_end], [y_start, y_end], 'r-', alpha=0.6) plt.title(\"Buffon's Needle Simulation\") plt.xlabel('X') plt.ylabel('Y') plt.ylim(-line_distance, line_distance * num_lines) plt.xlim(-needle_length, needle_length) plt.gca().set_aspect('equal') plt.show() def convergence_analysis_circle(max_points=100000, step=5000): \"\"\" Analyze convergence of pi estimation using circle method. Args: max_points (int): Maximum number of points. step (int): Step size for iterations. Returns: points_list (list): Number of points used. pi_estimates (list): Corresponding pi estimates. \"\"\" points_list = [] pi_estimates = [] for n in range(step, max_points + 1, step): pi_est, _, _ = estimate_pi_circle(n) points_list.append(n) pi_estimates.append(pi_est) return points_list, pi_estimates def convergence_analysis_buffon(max_throws=100000, step=5000): \"\"\" Analyze convergence of pi estimation using Buffon's Needle method. Args: max_throws (int): Maximum number of needle throws. step (int): Step size for iterations. Returns: throws_list (list): Number of throws used. pi_estimates (list): Corresponding pi estimates. \"\"\" throws_list = [] pi_estimates = [] for n in range(step, max_throws + 1, step): pi_est, crosses, _ = estimate_pi_buffon(n) throws_list.append(n) pi_estimates.append(pi_est) return throws_list, pi_estimates def plot_convergence(points_list, pi_estimates, throws_list, pi_estimates_buffon): \"\"\" Plot convergence of pi estimates for both methods. Args: points_list (list): Number of points for circle method. pi_estimates (list): Pi estimates for circle method. throws_list (list): Number of throws for Buffon's method. pi_estimates_buffon (list): Pi estimates for Buffon's method. \"\"\" plt.figure(figsize=(10,6)) plt.plot(points_list, pi_estimates, label='Circle Method') plt.plot(throws_list, pi_estimates_buffon, label=\"Buffon's Needle Method\") plt.axhline(y=np.pi, color='black', linestyle='--', label='True Pi') plt.xlabel('Number of Iterations') plt.ylabel('Estimated Pi') plt.title('Convergence of Pi Estimates') plt.legend() plt.show() if __name__ == \"__main__\": # Test and visualize circle method n_points = 10000 pi_est, pts, mask = estimate_pi_circle(n_points) print(f\"Circle Method: Estimated Pi = {pi_est:.6f} with {n_points} points\") plot_circle_simulation(pts, mask) # Test and visualize Buffon's Needle method n_throws = 10000 pi_est_b, crosses, needles = estimate_pi_buffon(n_throws) print(f\"Buffon's Needle Method: Estimated Pi = {pi_est_b:.6f} with {n_throws} throws and {crosses} crosses\") plot_buffon_needles(needles[:100], needle_length=1, line_distance=1) # Convergence analysis circle_points, circle_pis = convergence_analysis_circle(max_points=50000, step=5000) buffon_throws, buffon_pis = convergence_analysis_buffon(max_throws=50000, step=5000) plot_convergence(circle_points, circle_pis, buffon_throws, buffon_pis)","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-pi-using-monte-carlo-methods","text":"","title":"Estimating Pi using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#motivation","text":"Monte Carlo simulations are a powerful class of computational techniques that use randomness to solve problems or estimate values. One of the most elegant applications of Monte Carlo methods is estimating the value of \\(\\pi\\) through geometric probability. By randomly generating points and analyzing their positions relative to a geometric shape, we can approximate \\(\\pi\\) in an intuitive and visually engaging way. This problem connects fundamental concepts of probability, geometry, and numerical computation. It also provides a gateway to understanding how randomness can be harnessed to solve complex problems in physics, finance, and computer science. The Monte Carlo approach to \\(\\pi\\) estimation highlights the versatility and simplicity of this method while offering practical insights into convergence rates and computational efficiency.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-estimating-pi-using-a-circle","text":"","title":"Part 1: Estimating \\(\\pi\\) using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation","text":"Explain how the ratio of points inside a circle to the total number of points in a square can be used to estimate \\(\\pi\\) . Derive the formula \\[ \\pi \\approx 4 \\times \\frac{\\text{points inside the circle}}{\\text{total points}} \\] for a unit circle.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation","text":"Generate random points in a 2D square bounding a unit circle. Count the number of points falling inside the circle. Estimate \\(\\pi\\) based on the ratio of points inside the circle to the total points.","title":"2. Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization","text":"Create a plot showing the randomly generated points, distinguishing those inside and outside the circle.","title":"3. Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-analysis","text":"Investigate how the accuracy of the estimate improves as the number of points increases. Discuss the convergence rate and computational considerations for this method.","title":"4. Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-pi-using-buffons-needle","text":"","title":"Part 2: Estimating \\(\\pi\\) using Buffon's Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation_1","text":"Describe Buffon's Needle problem, where \\(\\pi\\) can be estimated based on the probability of a needle crossing parallel lines on a plane. Derive the formula: \\[ \\pi \\approx \\frac{2 \\times \\text{needle length} \\times \\text{number of throws}}{\\text{distance between lines} \\times \\text{number of crossings}} \\]","title":"1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation_1","text":"Simulate the random dropping of a needle on a plane with parallel lines. Count the number of times the needle crosses a line. Estimate \\(\\pi\\) based on the derived formula.","title":"2. Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization_1","text":"Create a graphical representation of the simulation, showing the needle positions relative to the lines.","title":"3. Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-analysis_1","text":"Explore how the number of needle drops affects the estimate's accuracy. Compare the convergence rate of this method to the circle-based approach.","title":"4. Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#deliverables","text":"A Markdown document with: Clear explanations of the methods and formulas. A discussion of theoretical foundations and results. Python scripts or notebooks implementing the simulations, including: Code for the circle-based Monte Carlo method. Code for Buffon's Needle method. Graphical outputs: Plots showing random points for the circle-based method. Visualizations of needle positions for Buffon's Needle. Analysis: Tables or graphs showing the convergence of estimated \\(\\pi\\) as a function of the number of iterations for both methods. A comparison of the methods in terms of accuracy and computational efficiency.","title":"Deliverables"},{"location":"1%20Physics/6%20Statistics/Problem_2/#hints-and-resources","text":"Use Python libraries such as NumPy for random number generation and Matplotlib for visualizations. For the circle-based method, ensure the random points are uniformly distributed within the square. For Buffon's Needle, pay attention to geometric constraints, such as the relationship between the needle length and the distance between lines. Start with a small number of iterations to validate the implementation, then increase the sample size to observe convergence.","title":"Hints and Resources"},{"location":"1%20Physics/6%20Statistics/Problem_2/#python-code","text":"import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(num_points): \"\"\" Estimate pi using the Monte Carlo method with random points inside a square. Points inside the unit circle are counted to estimate pi. Args: num_points (int): Number of random points to generate. Returns: pi_estimate (float): Estimated value of pi. points (ndarray): Generated points (num_points x 2). inside_mask (ndarray): Boolean mask for points inside the circle. \"\"\" # Generate random points in the square [-1, 1] x [-1, 1] points = np.random.uniform(low=-1, high=1, size=(num_points, 2)) # Calculate distances from origin (0,0) distances = np.linalg.norm(points, axis=1) # Mask for points inside the unit circle (distance <= 1) inside_mask = distances <= 1 # Estimate pi using ratio of points inside circle pi_estimate = 4 * np.sum(inside_mask) / num_points return pi_estimate, points, inside_mask def plot_circle_simulation(points, inside_mask): \"\"\" Plot the points generated for circle-based Monte Carlo simulation. Args: points (ndarray): Array of points (num_points x 2). inside_mask (ndarray): Boolean mask for points inside the circle. \"\"\" plt.figure(figsize=(6,6)) plt.scatter(points[inside_mask, 0], points[inside_mask, 1], color='blue', s=5, label='Inside Circle') plt.scatter(points[~inside_mask, 0], points[~inside_mask, 1], color='red', s=5, label='Outside Circle') circle = plt.Circle((0, 0), 1, color='black', fill=False, linewidth=1) plt.gca().add_artist(circle) plt.title('Monte Carlo Estimation of Pi - Circle Method') plt.xlabel('X') plt.ylabel('Y') plt.legend() plt.axis('square') plt.show() def estimate_pi_buffon(num_throws, needle_length=1, line_distance=1): \"\"\" Estimate pi using Buffon's Needle experiment. Args: num_throws (int): Number of needle drops. needle_length (float): Length of the needle. line_distance (float): Distance between parallel lines. Returns: pi_estimate (float): Estimated value of pi. crosses (int): Number of times needle crosses a line. needles (list of tuples): List of needle positions for visualization. Each needle is ((x_center, y_center), angle) \"\"\" crosses = 0 needles = [] for _ in range(num_throws): # Random position of needle center between 0 and line_distance / 2 center_y = np.random.uniform(0, line_distance / 2) # Random angle of needle with respect to the lines [0, pi/2] angle = np.random.uniform(0, np.pi / 2) # Calculate vertical projection of half needle length half_proj = (needle_length / 2) * np.sin(angle) # Check if needle crosses a line if center_y <= half_proj: crosses += 1 needles.append(((0, center_y), angle)) if crosses == 0: # Avoid division by zero pi_estimate = np.nan else: pi_estimate = (2 * needle_length * num_throws) / (line_distance * crosses) return pi_estimate, crosses, needles def plot_buffon_needles(needles, needle_length=1, line_distance=1, num_lines=5): \"\"\" Visualize Buffon's Needle simulation. Args: needles (list): List of needle positions ((x_center, y_center), angle). needle_length (float): Length of needles. line_distance (float): Distance between parallel lines. num_lines (int): Number of parallel lines to draw. \"\"\" plt.figure(figsize=(8, 6)) # Draw parallel lines for i in range(num_lines): y = i * line_distance plt.axhline(y=y, color='black', linewidth=1) # Plot needles for (x_center, y_center), angle in needles: x_start = x_center - (needle_length / 2) * np.cos(angle) x_end = x_center + (needle_length / 2) * np.cos(angle) y_start = y_center - (needle_length / 2) * np.sin(angle) y_end = y_center + (needle_length / 2) * np.sin(angle) plt.plot([x_start, x_end], [y_start, y_end], 'r-', alpha=0.6) plt.title(\"Buffon's Needle Simulation\") plt.xlabel('X') plt.ylabel('Y') plt.ylim(-line_distance, line_distance * num_lines) plt.xlim(-needle_length, needle_length) plt.gca().set_aspect('equal') plt.show() def convergence_analysis_circle(max_points=100000, step=5000): \"\"\" Analyze convergence of pi estimation using circle method. Args: max_points (int): Maximum number of points. step (int): Step size for iterations. Returns: points_list (list): Number of points used. pi_estimates (list): Corresponding pi estimates. \"\"\" points_list = [] pi_estimates = [] for n in range(step, max_points + 1, step): pi_est, _, _ = estimate_pi_circle(n) points_list.append(n) pi_estimates.append(pi_est) return points_list, pi_estimates def convergence_analysis_buffon(max_throws=100000, step=5000): \"\"\" Analyze convergence of pi estimation using Buffon's Needle method. Args: max_throws (int): Maximum number of needle throws. step (int): Step size for iterations. Returns: throws_list (list): Number of throws used. pi_estimates (list): Corresponding pi estimates. \"\"\" throws_list = [] pi_estimates = [] for n in range(step, max_throws + 1, step): pi_est, crosses, _ = estimate_pi_buffon(n) throws_list.append(n) pi_estimates.append(pi_est) return throws_list, pi_estimates def plot_convergence(points_list, pi_estimates, throws_list, pi_estimates_buffon): \"\"\" Plot convergence of pi estimates for both methods. Args: points_list (list): Number of points for circle method. pi_estimates (list): Pi estimates for circle method. throws_list (list): Number of throws for Buffon's method. pi_estimates_buffon (list): Pi estimates for Buffon's method. \"\"\" plt.figure(figsize=(10,6)) plt.plot(points_list, pi_estimates, label='Circle Method') plt.plot(throws_list, pi_estimates_buffon, label=\"Buffon's Needle Method\") plt.axhline(y=np.pi, color='black', linestyle='--', label='True Pi') plt.xlabel('Number of Iterations') plt.ylabel('Estimated Pi') plt.title('Convergence of Pi Estimates') plt.legend() plt.show() if __name__ == \"__main__\": # Test and visualize circle method n_points = 10000 pi_est, pts, mask = estimate_pi_circle(n_points) print(f\"Circle Method: Estimated Pi = {pi_est:.6f} with {n_points} points\") plot_circle_simulation(pts, mask) # Test and visualize Buffon's Needle method n_throws = 10000 pi_est_b, crosses, needles = estimate_pi_buffon(n_throws) print(f\"Buffon's Needle Method: Estimated Pi = {pi_est_b:.6f} with {n_throws} throws and {crosses} crosses\") plot_buffon_needles(needles[:100], needle_length=1, line_distance=1) # Convergence analysis circle_points, circle_pis = convergence_analysis_circle(max_points=50000, step=5000) buffon_throws, buffon_pis = convergence_analysis_buffon(max_throws=50000, step=5000) plot_convergence(circle_points, circle_pis, buffon_throws, buffon_pis)","title":"Python Code"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 Measuring Earth's Gravitational Acceleration with a Pendulum Motivation: The acceleration \\(g\\) due to gravity is a fundamental constant that influences a wide range of physical phenomena. Measuring \\(g\\) accurately is crucial for understanding gravitational interactions, designing structures, and conducting experiments in various fields. One classic method for determining \\(g\\) is through the oscillations of a simple pendulum, where the period of oscillation depends on the local gravitational field. Task: Measure the acceleration \\(g\\) due to gravity using a pendulum and analyze the uncertainties in the measurements in detail. This exercise emphasizes rigorous measurement practices, uncertainty analysis, and their role in experimental physics. Procedure: 1. Materials: A string (1 or 1.5 meters long). A small weight (e.g., bag of coins, bag of sugar, key chain) mounted on the string. Stopwatch (or smartphone timer). Ruler or measuring tape. 2. Setup: Attach the weight to the string and fix the other end to a sturdy support. Measure the length of the pendulum, \\(L\\) , from the suspension point to the center of the weight using a ruler or measuring tape. Record the resolution of the measuring tool and calculate the uncertainty as half the resolution: \\[ \\Delta L = \\frac{\\text{Ruler Resolution}}{2} \\] 3. Data Collection: Displace the pendulum slightly (<15\u00b0) and release it. Measure the time for 10 full oscillations ( \\(T_{10}\\) ) and repeat this process 10 times. Record all 10 measurements. Calculate the mean time for 10 oscillations ( \\(\\overline{T}_{10}\\) ) and the standard deviation ( \\(\\sigma_{T}\\) ). Determine the uncertainty in the mean time as: \\[ \\Delta T_{10} = \\frac{\\sigma_{T}}{\\sqrt{n}} \\] where \\(n = 10\\) . Calculations: Calculate the period: \\[ T = \\frac{\\overline{T}_{10}}{10} \\quad \\text{and} \\quad \\Delta T = \\frac{\\Delta T_{10}}{10} \\] Determine \\(g\\) : \\[ g = \\frac{4 \\pi^2 L}{T^2} \\] Propagate uncertainties: \\[ \\Delta g = g \\sqrt{\\left(\\frac{\\Delta L}{L}\\right)^2 + \\left(2 \\frac{\\Delta T}{T}\\right)^2} \\] Analysis: Compare your measured \\(g\\) with the standard value \\((9.81 \\, m/s^2)\\) . Discuss: The effect of measurement resolution on \\(\\Delta L\\) . Variability in timing and its impact on \\(\\Delta T\\) . Any assumptions or experimental limitations. Deliverables: Tabulated data in markdown: \\(L\\) , \\(\\Delta L\\) , \\(T_{10}\\) measurements, \\(\\overline{T}_{10}\\) , \\(\\sigma_T\\) , \\(\\Delta T\\) . Calculated \\(g\\) and \\(\\Delta g\\) . Discussion on sources of uncertainty and their impact on results. Python Code ```python import numpy as np import pandas as pd Constants pi = np.pi Given parameters L = 1.0 # length of pendulum in meters (can be 1 or 1.5 as per setup) ruler_resolution = 0.001 # ruler resolution in meters (1 mm) delta_L = ruler_resolution / 2 # uncertainty in length Number of measurements n = 10 Simulate 10 measurements of time for 10 oscillations (seconds) Let's simulate realistic values around the theoretical period for a pendulum of length L Theoretical period for 1 oscillation: T_theoretical = 2 * pi * np.sqrt(L / 9.81) # seconds Time for 10 oscillations: T10_theoretical = 10 * T_theoretical Simulate measured times with some random noise to represent measurement variability np.random.seed(42) # for reproducibility Assume standard deviation of measurement ~0.05 seconds for T10 sigma_T_meas = 0.05 T10_measurements = np.random.normal(loc=T10_theoretical, scale=sigma_T_meas, size=n) Calculate mean and standard deviation T10_mean = np.mean(T10_measurements) sigma_T = np.std(T10_measurements, ddof=1) Uncertainty in mean time delta_T10 = sigma_T / np.sqrt(n) Calculate period and uncertainty for one oscillation T = T10_mean / 10 delta_T = delta_T10 / 10 Calculate g and its uncertainty g = 4 * pi 2 * L / T 2 delta_g = g * np.sqrt((delta_L / L) 2 + (2 * delta_T / T) 2) Prepare data for display data = { 'T10_measurements (s)': T10_measurements, 'L (m)': [L] n, '\u0394L (m)': [delta_L] n } df = pd.DataFrame(data) Summary calculations summary = { 'Mean T10 (s)': T10_mean, 'Std Dev \u03c3_T (s)': sigma_T, 'Uncertainty \u0394T10 (s)': delta_T10, 'Period T (s)': T, 'Uncertainty \u0394T (s)': delta_T, 'Measured g (m/s^2)': g, 'Uncertainty \u0394g (m/s^2)': delta_g, 'Standard g (m/s^2)': 9.81, 'Difference from standard (m/s^2)': g - 9.81 } Print results print(\"\\n--- Pendulum Gravity Measurement Data ---\\n\") print(df.to_markdown(index=False)) print(\"\\n--- Summary ---\\n\") for key, value in summary.items(): print(f\"{key}: {value:.5f}\") Markdown formatted summary for report markdown_summary = \"\\n\".join([f\"- {key} : {value:.5f}\" for key, value in summary.items()]) print(\"\\n--- Markdown summary for report ---\\n\") print(markdown_summary)","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#motivation","text":"The acceleration \\(g\\) due to gravity is a fundamental constant that influences a wide range of physical phenomena. Measuring \\(g\\) accurately is crucial for understanding gravitational interactions, designing structures, and conducting experiments in various fields. One classic method for determining \\(g\\) is through the oscillations of a simple pendulum, where the period of oscillation depends on the local gravitational field.","title":"Motivation:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#task","text":"Measure the acceleration \\(g\\) due to gravity using a pendulum and analyze the uncertainties in the measurements in detail. This exercise emphasizes rigorous measurement practices, uncertainty analysis, and their role in experimental physics.","title":"Task:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#procedure","text":"","title":"Procedure:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-materials","text":"A string (1 or 1.5 meters long). A small weight (e.g., bag of coins, bag of sugar, key chain) mounted on the string. Stopwatch (or smartphone timer). Ruler or measuring tape.","title":"1. Materials:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-setup","text":"Attach the weight to the string and fix the other end to a sturdy support. Measure the length of the pendulum, \\(L\\) , from the suspension point to the center of the weight using a ruler or measuring tape. Record the resolution of the measuring tool and calculate the uncertainty as half the resolution: \\[ \\Delta L = \\frac{\\text{Ruler Resolution}}{2} \\]","title":"2. Setup:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-data-collection","text":"Displace the pendulum slightly (<15\u00b0) and release it. Measure the time for 10 full oscillations ( \\(T_{10}\\) ) and repeat this process 10 times. Record all 10 measurements. Calculate the mean time for 10 oscillations ( \\(\\overline{T}_{10}\\) ) and the standard deviation ( \\(\\sigma_{T}\\) ). Determine the uncertainty in the mean time as: \\[ \\Delta T_{10} = \\frac{\\sigma_{T}}{\\sqrt{n}} \\] where \\(n = 10\\) .","title":"3. Data Collection:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"Calculate the period: \\[ T = \\frac{\\overline{T}_{10}}{10} \\quad \\text{and} \\quad \\Delta T = \\frac{\\Delta T_{10}}{10} \\] Determine \\(g\\) : \\[ g = \\frac{4 \\pi^2 L}{T^2} \\] Propagate uncertainties: \\[ \\Delta g = g \\sqrt{\\left(\\frac{\\Delta L}{L}\\right)^2 + \\left(2 \\frac{\\Delta T}{T}\\right)^2} \\]","title":"Calculations:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#analysis","text":"Compare your measured \\(g\\) with the standard value \\((9.81 \\, m/s^2)\\) . Discuss: The effect of measurement resolution on \\(\\Delta L\\) . Variability in timing and its impact on \\(\\Delta T\\) . Any assumptions or experimental limitations.","title":"Analysis:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#deliverables","text":"Tabulated data in markdown: \\(L\\) , \\(\\Delta L\\) , \\(T_{10}\\) measurements, \\(\\overline{T}_{10}\\) , \\(\\sigma_T\\) , \\(\\Delta T\\) . Calculated \\(g\\) and \\(\\Delta g\\) . Discussion on sources of uncertainty and their impact on results.","title":"Deliverables:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#python-code","text":"```python import numpy as np import pandas as pd","title":"Python Code"},{"location":"1%20Physics/7%20Measurements/Problem_1/#constants","text":"pi = np.pi","title":"Constants"},{"location":"1%20Physics/7%20Measurements/Problem_1/#given-parameters","text":"L = 1.0 # length of pendulum in meters (can be 1 or 1.5 as per setup) ruler_resolution = 0.001 # ruler resolution in meters (1 mm) delta_L = ruler_resolution / 2 # uncertainty in length","title":"Given parameters"},{"location":"1%20Physics/7%20Measurements/Problem_1/#number-of-measurements","text":"n = 10","title":"Number of measurements"},{"location":"1%20Physics/7%20Measurements/Problem_1/#simulate-10-measurements-of-time-for-10-oscillations-seconds","text":"","title":"Simulate 10 measurements of time for 10 oscillations (seconds)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#lets-simulate-realistic-values-around-the-theoretical-period-for-a-pendulum-of-length-l","text":"","title":"Let's simulate realistic values around the theoretical period for a pendulum of length L"},{"location":"1%20Physics/7%20Measurements/Problem_1/#theoretical-period-for-1-oscillation","text":"T_theoretical = 2 * pi * np.sqrt(L / 9.81) # seconds","title":"Theoretical period for 1 oscillation:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#time-for-10-oscillations","text":"T10_theoretical = 10 * T_theoretical","title":"Time for 10 oscillations:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#simulate-measured-times-with-some-random-noise-to-represent-measurement-variability","text":"np.random.seed(42) # for reproducibility","title":"Simulate measured times with some random noise to represent measurement variability"},{"location":"1%20Physics/7%20Measurements/Problem_1/#assume-standard-deviation-of-measurement-005-seconds-for-t10","text":"sigma_T_meas = 0.05 T10_measurements = np.random.normal(loc=T10_theoretical, scale=sigma_T_meas, size=n)","title":"Assume standard deviation of measurement ~0.05 seconds for T10"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculate-mean-and-standard-deviation","text":"T10_mean = np.mean(T10_measurements) sigma_T = np.std(T10_measurements, ddof=1)","title":"Calculate mean and standard deviation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#uncertainty-in-mean-time","text":"delta_T10 = sigma_T / np.sqrt(n)","title":"Uncertainty in mean time"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculate-period-and-uncertainty-for-one-oscillation","text":"T = T10_mean / 10 delta_T = delta_T10 / 10","title":"Calculate period and uncertainty for one oscillation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculate-g-and-its-uncertainty","text":"g = 4 * pi 2 * L / T 2 delta_g = g * np.sqrt((delta_L / L) 2 + (2 * delta_T / T) 2)","title":"Calculate g and its uncertainty"},{"location":"1%20Physics/7%20Measurements/Problem_1/#prepare-data-for-display","text":"data = { 'T10_measurements (s)': T10_measurements, 'L (m)': [L] n, '\u0394L (m)': [delta_L] n } df = pd.DataFrame(data)","title":"Prepare data for display"},{"location":"1%20Physics/7%20Measurements/Problem_1/#summary-calculations","text":"summary = { 'Mean T10 (s)': T10_mean, 'Std Dev \u03c3_T (s)': sigma_T, 'Uncertainty \u0394T10 (s)': delta_T10, 'Period T (s)': T, 'Uncertainty \u0394T (s)': delta_T, 'Measured g (m/s^2)': g, 'Uncertainty \u0394g (m/s^2)': delta_g, 'Standard g (m/s^2)': 9.81, 'Difference from standard (m/s^2)': g - 9.81 }","title":"Summary calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#print-results","text":"print(\"\\n--- Pendulum Gravity Measurement Data ---\\n\") print(df.to_markdown(index=False)) print(\"\\n--- Summary ---\\n\") for key, value in summary.items(): print(f\"{key}: {value:.5f}\")","title":"Print results"},{"location":"1%20Physics/7%20Measurements/Problem_1/#markdown-formatted-summary-for-report","text":"markdown_summary = \"\\n\".join([f\"- {key} : {value:.5f}\" for key, value in summary.items()]) print(\"\\n--- Markdown summary for report ---\\n\") print(markdown_summary)","title":"Markdown formatted summary for report"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}